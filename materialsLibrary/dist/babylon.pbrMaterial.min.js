var __decorate=this&&this.__decorate||function(e,i,n,t){if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)return Reflect.decorate(e,i,n,t);switch(arguments.length){case 2:return e.reduceRight(function(e,i){return i&&i(e)||e},i);case 3:return e.reduceRight(function(e,t){return void(t&&t(i,n))},void 0);case 4:return e.reduceRight(function(e,t){return t&&t(i,n,e)||e},t)}},BABYLON;!function(e){var i=4,n=function(e){function i(){e.call(this),this.ALBEDO=!1,this.AMBIENT=!1,this.OPACITY=!1,this.OPACITYRGB=!1,this.REFLECTION=!1,this.EMISSIVE=!1,this.REFLECTIVITY=!1,this.BUMP=!1,this.SPECULAROVERALPHA=!1,this.CLIPPLANE=!1,this.ALPHATEST=!1,this.ALPHAFROMALBEDO=!1,this.POINTSIZE=!1,this.FOG=!1,this.LIGHT0=!1,this.LIGHT1=!1,this.LIGHT2=!1,this.LIGHT3=!1,this.SPOTLIGHT0=!1,this.SPOTLIGHT1=!1,this.SPOTLIGHT2=!1,this.SPOTLIGHT3=!1,this.HEMILIGHT0=!1,this.HEMILIGHT1=!1,this.HEMILIGHT2=!1,this.HEMILIGHT3=!1,this.POINTLIGHT0=!1,this.POINTLIGHT1=!1,this.POINTLIGHT2=!1,this.POINTLIGHT3=!1,this.DIRLIGHT0=!1,this.DIRLIGHT1=!1,this.DIRLIGHT2=!1,this.DIRLIGHT3=!1,this.SPECULARTERM=!1,this.SHADOW0=!1,this.SHADOW1=!1,this.SHADOW2=!1,this.SHADOW3=!1,this.SHADOWS=!1,this.SHADOWVSM0=!1,this.SHADOWVSM1=!1,this.SHADOWVSM2=!1,this.SHADOWVSM3=!1,this.SHADOWPCF0=!1,this.SHADOWPCF1=!1,this.SHADOWPCF2=!1,this.SHADOWPCF3=!1,this.OPACITYFRESNEL=!1,this.EMISSIVEFRESNEL=!1,this.FRESNEL=!1,this.NORMAL=!1,this.UV1=!1,this.UV2=!1,this.VERTEXCOLOR=!1,this.VERTEXALPHA=!1,this.NUM_BONE_INFLUENCERS=0,this.BonesPerMesh=0,this.INSTANCES=!1,this.MICROSURFACEFROMREFLECTIVITYMAP=!1,this.MICROSURFACEAUTOMATIC=!1,this.EMISSIVEASILLUMINATION=!1,this.LINKEMISSIVEWITHALBEDO=!1,this.LIGHTMAP=!1,this.USELIGHTMAPASSHADOWMAP=!1,this.REFLECTIONMAP_3D=!1,this.REFLECTIONMAP_SPHERICAL=!1,this.REFLECTIONMAP_PLANAR=!1,this.REFLECTIONMAP_CUBIC=!1,this.REFLECTIONMAP_PROJECTION=!1,this.REFLECTIONMAP_SKYBOX=!1,this.REFLECTIONMAP_EXPLICIT=!1,this.REFLECTIONMAP_EQUIRECTANGULAR=!1,this.INVERTCUBICMAP=!1,this.LOGARITHMICDEPTH=!1,this.CAMERATONEMAP=!1,this.CAMERACONTRAST=!1,this.OVERLOADEDVALUES=!1,this.OVERLOADEDSHADOWVALUES=!1,this.USESPHERICALFROMREFLECTIONMAP=!1,this.REFRACTION=!1,this.REFRACTIONMAP_3D=!1,this.LINKREFRACTIONTOTRANSPARENCY=!1,this.REFRACTIONMAPINLINEARSPACE=!1,this.LODBASEDMICROSFURACE=!1,this.USEPHYSICALLIGHTFALLOFF=!1,this.RADIANCEOVERALPHA=!1,this._keys=Object.keys(this)}return __extends(i,e),i}(e.MaterialDefines),t=function(t){function o(i,o){var r=this;t.call(this,i,o),this.directIntensity=1,this.emissiveIntensity=1,this.environmentIntensity=1,this.specularIntensity=1,this._lightingInfos=new e.Vector4(this.directIntensity,this.emissiveIntensity,this.environmentIntensity,this.specularIntensity),this.overloadedShadowIntensity=1,this.overloadedShadeIntensity=1,this._overloadedShadowInfos=new e.Vector4(this.overloadedShadowIntensity,this.overloadedShadeIntensity,0,0),this.cameraExposure=1,this.cameraContrast=1,this._cameraInfos=new e.Vector4(1,1,0,0),this._microsurfaceTextureLods=new e.Vector2(0,0),this.overloadedAmbientIntensity=0,this.overloadedAlbedoIntensity=0,this.overloadedReflectivityIntensity=0,this.overloadedEmissiveIntensity=0,this._overloadedIntensity=new e.Vector4(this.overloadedAmbientIntensity,this.overloadedAlbedoIntensity,this.overloadedReflectivityIntensity,this.overloadedEmissiveIntensity),this.overloadedAmbient=e.Color3.White(),this.overloadedAlbedo=e.Color3.White(),this.overloadedReflectivity=e.Color3.White(),this.overloadedEmissive=e.Color3.White(),this.overloadedReflection=e.Color3.White(),this.overloadedMicroSurface=0,this.overloadedMicroSurfaceIntensity=0,this.overloadedReflectionIntensity=0,this._overloadedMicroSurface=new e.Vector3(this.overloadedMicroSurface,this.overloadedMicroSurfaceIntensity,this.overloadedReflectionIntensity),this.disableBumpMap=!1,this.ambientColor=new e.Color3(0,0,0),this.albedoColor=new e.Color3(1,1,1),this.reflectivityColor=new e.Color3(1,1,1),this.reflectionColor=new e.Color3(.5,.5,.5),this.emissiveColor=new e.Color3(0,0,0),this.microSurface=.5,this.indexOfRefraction=.66,this.invertRefractionY=!1,this.linkRefractionWithTransparency=!1,this.linkEmissiveWithAlbedo=!1,this.useLightmapAsShadowmap=!1,this.useEmissiveAsIllumination=!1,this.useAlphaFromAlbedoTexture=!1,this.useSpecularOverAlpha=!0,this.useMicroSurfaceFromReflectivityMapAlpha=!1,this.useAutoMicroSurfaceFromReflectivityMap=!1,this.useScalarInLinearSpace=!1,this.usePhysicalLightFalloff=!0,this.useRadianceOverAlpha=!0,this.disableLighting=!1,this._renderTargets=new e.SmartArray(16),this._worldViewProjectionMatrix=e.Matrix.Zero(),this._globalAmbientColor=new e.Color3(0,0,0),this._tempColor=new e.Color3,this._defines=new n,this._cachedDefines=new n,this._myScene=null,this._myShadowGenerator=null,this._cachedDefines.BonesPerMesh=-1,this.getRenderTargetTextures=function(){return r._renderTargets.reset(),r.reflectionTexture&&r.reflectionTexture.isRenderTarget&&r._renderTargets.push(r.reflectionTexture),r.refractionTexture&&r.refractionTexture.isRenderTarget&&r._renderTargets.push(r.refractionTexture),r._renderTargets}}return __extends(o,t),Object.defineProperty(o.prototype,"useLogarithmicDepth",{get:function(){return this._useLogarithmicDepth},set:function(e){this._useLogarithmicDepth=e&&this.getScene().getEngine().getCaps().fragmentDepthSupported},enumerable:!0,configurable:!0}),o.prototype.needAlphaBlending=function(){return this.linkRefractionWithTransparency?!1:this.alpha<1||null!=this.opacityTexture||this._shouldUseAlphaFromAlbedoTexture()||this.opacityFresnelParameters&&this.opacityFresnelParameters.isEnabled},o.prototype.needAlphaTesting=function(){return this.linkRefractionWithTransparency?!1:null!=this.albedoTexture&&this.albedoTexture.hasAlpha},o.prototype._shouldUseAlphaFromAlbedoTexture=function(){return null!=this.albedoTexture&&this.albedoTexture.hasAlpha&&this.useAlphaFromAlbedoTexture},o.prototype.getAlphaTestTexture=function(){return this.albedoTexture},o.prototype._checkCache=function(e,i,n){return i?this._defines.INSTANCES!==n?!1:i._materialDefines&&i._materialDefines.isEqual(this._defines)?!0:!1:!0},o.prototype.convertColorToLinearSpaceToRef=function(e,i){o.convertColorToLinearSpaceToRef(e,i,this.useScalarInLinearSpace)},o.convertColorToLinearSpaceToRef=function(e,i,n){n?(i.r=e.r,i.g=e.g,i.b=e.b):e.toLinearSpaceToRef(i)},o.BindLights=function(n,t,r,a,s){for(var l=0,f=!1,c=0;c<n.lights.length;c++){var d=n.lights[c];if(d.isEnabled()&&d.canAffectMesh(t)&&(this._lightRadiuses[l]=d.radius,e.MaterialHelper.BindLightProperties(d,r,l),this.convertColorToLinearSpaceToRef(d.diffuse,o._scaledAlbedo,s),o._scaledAlbedo.scaleToRef(d.intensity,o._scaledAlbedo),r.setColor4("vLightDiffuse"+l,o._scaledAlbedo,d.range),a.SPECULARTERM&&(this.convertColorToLinearSpaceToRef(d.specular,o._scaledReflectivity,s),o._scaledReflectivity.scaleToRef(d.intensity,o._scaledReflectivity),r.setColor3("vLightSpecular"+l,o._scaledReflectivity)),n.shadowsEnabled&&(f=e.MaterialHelper.BindLightShadow(d,n,t,l,r,f)),l++,l===i))break}r.setFloat4("vLightRadiuses",this._lightRadiuses[0],this._lightRadiuses[1],this._lightRadiuses[2],this._lightRadiuses[3])},o.prototype.isReady=function(i,t){if(this.checkReadyOnlyOnce&&this._wasPreviouslyReady)return!0;var o=this.getScene();if(!this.checkReadyOnEveryCall&&this._renderId===o.getRenderId()&&this._checkCache(o,i,t))return!0;var r=o.getEngine(),a=!1,s=!1;if(this._defines.reset(),o.texturesEnabled){if(o.texturesEnabled){if(o.getEngine().getCaps().textureLOD&&(this._defines.LODBASEDMICROSFURACE=!0),this.albedoTexture&&e.StandardMaterial.DiffuseTextureEnabled){if(!this.albedoTexture.isReady())return!1;s=!0,this._defines.ALBEDO=!0}if(this.ambientTexture&&e.StandardMaterial.AmbientTextureEnabled){if(!this.ambientTexture.isReady())return!1;s=!0,this._defines.AMBIENT=!0}if(this.opacityTexture&&e.StandardMaterial.OpacityTextureEnabled){if(!this.opacityTexture.isReady())return!1;s=!0,this._defines.OPACITY=!0,this.opacityTexture.getAlphaFromRGB&&(this._defines.OPACITYRGB=!0)}if(this.reflectionTexture&&e.StandardMaterial.ReflectionTextureEnabled){if(!this.reflectionTexture.isReady())return!1;switch(a=!0,this._defines.REFLECTION=!0,this.reflectionTexture.coordinatesMode===e.Texture.INVCUBIC_MODE&&(this._defines.INVERTCUBICMAP=!0),this._defines.REFLECTIONMAP_3D=this.reflectionTexture.isCube,this.reflectionTexture.coordinatesMode){case e.Texture.CUBIC_MODE:case e.Texture.INVCUBIC_MODE:this._defines.REFLECTIONMAP_CUBIC=!0;break;case e.Texture.EXPLICIT_MODE:this._defines.REFLECTIONMAP_EXPLICIT=!0;break;case e.Texture.PLANAR_MODE:this._defines.REFLECTIONMAP_PLANAR=!0;break;case e.Texture.PROJECTION_MODE:this._defines.REFLECTIONMAP_PROJECTION=!0;break;case e.Texture.SKYBOX_MODE:this._defines.REFLECTIONMAP_SKYBOX=!0;break;case e.Texture.SPHERICAL_MODE:this._defines.REFLECTIONMAP_SPHERICAL=!0;break;case e.Texture.EQUIRECTANGULAR_MODE:this._defines.REFLECTIONMAP_EQUIRECTANGULAR=!0}this.reflectionTexture instanceof e.HDRCubeTexture&&this.reflectionTexture&&(this._defines.USESPHERICALFROMREFLECTIONMAP=!0,a=!0)}if(this.lightmapTexture&&e.StandardMaterial.LightmapTextureEnabled){if(!this.lightmapTexture.isReady())return!1;s=!0,this._defines.LIGHTMAP=!0,this._defines.USELIGHTMAPASSHADOWMAP=this.useLightmapAsShadowmap}if(this.emissiveTexture&&e.StandardMaterial.EmissiveTextureEnabled){if(!this.emissiveTexture.isReady())return!1;s=!0,this._defines.EMISSIVE=!0}if(this.reflectivityTexture&&e.StandardMaterial.SpecularTextureEnabled){if(!this.reflectivityTexture.isReady())return!1;s=!0,this._defines.REFLECTIVITY=!0,this._defines.MICROSURFACEFROMREFLECTIVITYMAP=this.useMicroSurfaceFromReflectivityMapAlpha,this._defines.MICROSURFACEAUTOMATIC=this.useAutoMicroSurfaceFromReflectivityMap}}if(o.getEngine().getCaps().standardDerivatives&&this.bumpTexture&&e.StandardMaterial.BumpTextureEnabled&&!this.disableBumpMap){if(!this.bumpTexture.isReady())return!1;s=!0,this._defines.BUMP=!0}if(this.refractionTexture&&e.StandardMaterial.RefractionTextureEnabled){if(!this.refractionTexture.isReady())return!1;s=!0,this._defines.REFRACTION=!0,this._defines.REFRACTIONMAP_3D=this.refractionTexture.isCube,this.linkRefractionWithTransparency&&(this._defines.LINKREFRACTIONTOTRANSPARENCY=!0),this.refractionTexture instanceof e.HDRCubeTexture&&(this._defines.REFRACTIONMAPINLINEARSPACE=!0)}}if(o.clipPlane&&(this._defines.CLIPPLANE=!0),r.getAlphaTesting()&&(this._defines.ALPHATEST=!0),this._shouldUseAlphaFromAlbedoTexture()&&(this._defines.ALPHAFROMALBEDO=!0),this.useEmissiveAsIllumination&&(this._defines.EMISSIVEASILLUMINATION=!0),this.linkEmissiveWithAlbedo&&(this._defines.LINKEMISSIVEWITHALBEDO=!0),this.useLogarithmicDepth&&(this._defines.LOGARITHMICDEPTH=!0),1!=this.cameraContrast&&(this._defines.CAMERACONTRAST=!0),1!=this.cameraExposure&&(this._defines.CAMERATONEMAP=!0),(1!=this.overloadedShadeIntensity||1!=this.overloadedShadowIntensity)&&(this._defines.OVERLOADEDSHADOWVALUES=!0),(this.overloadedMicroSurfaceIntensity>0||this.overloadedEmissiveIntensity>0||this.overloadedReflectivityIntensity>0||this.overloadedAlbedoIntensity>0||this.overloadedAmbientIntensity>0||this.overloadedReflectionIntensity>0)&&(this._defines.OVERLOADEDVALUES=!0),(this.pointsCloud||o.forcePointsCloud)&&(this._defines.POINTSIZE=!0),o.fogEnabled&&i&&i.applyFog&&o.fogMode!==e.Scene.FOGMODE_NONE&&this.fogEnabled&&(this._defines.FOG=!0),o.lightsEnabled&&!this.disableLighting&&(a=e.MaterialHelper.PrepareDefinesForLights(o,i,this._defines)||a),e.StandardMaterial.FresnelEnabled&&(this.opacityFresnelParameters&&this.opacityFresnelParameters.isEnabled||this.emissiveFresnelParameters&&this.emissiveFresnelParameters.isEnabled)&&(this.opacityFresnelParameters&&this.opacityFresnelParameters.isEnabled&&(this._defines.OPACITYFRESNEL=!0),this.emissiveFresnelParameters&&this.emissiveFresnelParameters.isEnabled&&(this._defines.EMISSIVEFRESNEL=!0),a=!0,this._defines.FRESNEL=!0),this._defines.SPECULARTERM&&this.useSpecularOverAlpha&&(this._defines.SPECULAROVERALPHA=!0),this.usePhysicalLightFalloff&&(this._defines.USEPHYSICALLIGHTFALLOFF=!0),this.useRadianceOverAlpha&&(this._defines.RADIANCEOVERALPHA=!0),i&&(a&&i.isVerticesDataPresent(e.VertexBuffer.NormalKind)&&(this._defines.NORMAL=!0),s&&(i.isVerticesDataPresent(e.VertexBuffer.UVKind)&&(this._defines.UV1=!0),i.isVerticesDataPresent(e.VertexBuffer.UV2Kind)&&(this._defines.UV2=!0)),i.useVertexColors&&i.isVerticesDataPresent(e.VertexBuffer.ColorKind)&&(this._defines.VERTEXCOLOR=!0,i.hasVertexAlpha&&(this._defines.VERTEXALPHA=!0)),i.useBones&&i.computeBonesUsingShaders&&(this._defines.NUM_BONE_INFLUENCERS=i.numBoneInfluencers,this._defines.BonesPerMesh=i.skeleton.bones.length+1),t&&(this._defines.INSTANCES=!0)),!this._defines.isEqual(this._cachedDefines)){this._defines.cloneTo(this._cachedDefines),o.resetCachedMaterial();var l=new e.EffectFallbacks;this._defines.REFLECTION&&l.addFallback(0,"REFLECTION"),this._defines.REFLECTIVITY&&l.addFallback(0,"REFLECTIVITY"),this._defines.BUMP&&l.addFallback(0,"BUMP"),this._defines.SPECULAROVERALPHA&&l.addFallback(0,"SPECULAROVERALPHA"),this._defines.FOG&&l.addFallback(1,"FOG"),this._defines.POINTSIZE&&l.addFallback(0,"POINTSIZE"),this._defines.LOGARITHMICDEPTH&&l.addFallback(0,"LOGARITHMICDEPTH"),e.MaterialHelper.HandleFallbacksForShadows(this._defines,l),this._defines.SPECULARTERM&&l.addFallback(0,"SPECULARTERM"),this._defines.OPACITYFRESNEL&&l.addFallback(1,"OPACITYFRESNEL"),this._defines.EMISSIVEFRESNEL&&l.addFallback(2,"EMISSIVEFRESNEL"),this._defines.FRESNEL&&l.addFallback(3,"FRESNEL"),this._defines.NUM_BONE_INFLUENCERS>0&&l.addCPUSkinningFallback(0,i);var f=[e.VertexBuffer.PositionKind];this._defines.NORMAL&&f.push(e.VertexBuffer.NormalKind),this._defines.UV1&&f.push(e.VertexBuffer.UVKind),this._defines.UV2&&f.push(e.VertexBuffer.UV2Kind),this._defines.VERTEXCOLOR&&f.push(e.VertexBuffer.ColorKind),e.MaterialHelper.PrepareAttributesForBones(f,i,this._defines,l),e.MaterialHelper.PrepareAttributesForInstances(f,this._defines);var c="pbr";o.getEngine().getCaps().standardDerivatives||(c="legacypbr");var d=this._defines.toString();this._effect=o.getEngine().createEffect(c,f,["world","view","viewProjection","vEyePosition","vLightsType","vAmbientColor","vAlbedoColor","vReflectivityColor","vEmissiveColor","vReflectionColor","vLightData0","vLightDiffuse0","vLightSpecular0","vLightDirection0","vLightGround0","lightMatrix0","vLightData1","vLightDiffuse1","vLightSpecular1","vLightDirection1","vLightGround1","lightMatrix1","vLightData2","vLightDiffuse2","vLightSpecular2","vLightDirection2","vLightGround2","lightMatrix2","vLightData3","vLightDiffuse3","vLightSpecular3","vLightDirection3","vLightGround3","lightMatrix3","vFogInfos","vFogColor","pointSize","vAlbedoInfos","vAmbientInfos","vOpacityInfos","vReflectionInfos","vEmissiveInfos","vReflectivityInfos","vBumpInfos","vLightmapInfos","vRefractionInfos","mBones","vClipPlane","albedoMatrix","ambientMatrix","opacityMatrix","reflectionMatrix","emissiveMatrix","reflectivityMatrix","bumpMatrix","lightmapMatrix","refractionMatrix","shadowsInfo0","shadowsInfo1","shadowsInfo2","shadowsInfo3","depthValues","opacityParts","emissiveLeftColor","emissiveRightColor","vLightingIntensity","vOverloadedShadowIntensity","vOverloadedIntensity","vCameraInfos","vOverloadedAlbedo","vOverloadedReflection","vOverloadedReflectivity","vOverloadedEmissive","vOverloadedMicroSurface","logarithmicDepthConstant","vSphericalX","vSphericalY","vSphericalZ","vSphericalXX","vSphericalYY","vSphericalZZ","vSphericalXY","vSphericalYZ","vSphericalZX","vMicrosurfaceTextureLods","vLightRadiuses"],["albedoSampler","ambientSampler","opacitySampler","reflectionCubeSampler","reflection2DSampler","emissiveSampler","reflectivitySampler","bumpSampler","lightmapSampler","refractionCubeSampler","refraction2DSampler","shadowSampler0","shadowSampler1","shadowSampler2","shadowSampler3"],d,l,this.onCompiled,this.onError)}return this._effect.isReady()?(this._renderId=o.getRenderId(),this._wasPreviouslyReady=!0,i&&(i._materialDefines||(i._materialDefines=new n),this._defines.cloneTo(i._materialDefines)),!0):!1},o.prototype.unbind=function(){this.reflectionTexture&&this.reflectionTexture.isRenderTarget&&this._effect.setTexture("reflection2DSampler",null),this.refractionTexture&&this.refractionTexture.isRenderTarget&&this._effect.setTexture("refraction2DSampler",null),t.prototype.unbind.call(this)},o.prototype.bindOnlyWorldMatrix=function(e){this._effect.setMatrix("world",e)},o.prototype.bind=function(i,n){if(this._myScene=this.getScene(),this.bindOnlyWorldMatrix(i),e.MaterialHelper.BindBonesParameters(n,this._effect),this._myScene.getCachedMaterial()!==this){if(this._effect.setMatrix("viewProjection",this._myScene.getTransformMatrix()),e.StandardMaterial.FresnelEnabled&&(this.opacityFresnelParameters&&this.opacityFresnelParameters.isEnabled&&this._effect.setColor4("opacityParts",new e.Color3(this.opacityFresnelParameters.leftColor.toLuminance(),this.opacityFresnelParameters.rightColor.toLuminance(),this.opacityFresnelParameters.bias),this.opacityFresnelParameters.power),this.emissiveFresnelParameters&&this.emissiveFresnelParameters.isEnabled&&(this._effect.setColor4("emissiveLeftColor",this.emissiveFresnelParameters.leftColor,this.emissiveFresnelParameters.power),this._effect.setColor4("emissiveRightColor",this.emissiveFresnelParameters.rightColor,this.emissiveFresnelParameters.bias))),this._myScene.texturesEnabled){if(this.albedoTexture&&e.StandardMaterial.DiffuseTextureEnabled&&(this._effect.setTexture("albedoSampler",this.albedoTexture),this._effect.setFloat2("vAlbedoInfos",this.albedoTexture.coordinatesIndex,this.albedoTexture.level),this._effect.setMatrix("albedoMatrix",this.albedoTexture.getTextureMatrix())),this.ambientTexture&&e.StandardMaterial.AmbientTextureEnabled&&(this._effect.setTexture("ambientSampler",this.ambientTexture),this._effect.setFloat2("vAmbientInfos",this.ambientTexture.coordinatesIndex,this.ambientTexture.level),this._effect.setMatrix("ambientMatrix",this.ambientTexture.getTextureMatrix())),this.opacityTexture&&e.StandardMaterial.OpacityTextureEnabled&&(this._effect.setTexture("opacitySampler",this.opacityTexture),this._effect.setFloat2("vOpacityInfos",this.opacityTexture.coordinatesIndex,this.opacityTexture.level),this._effect.setMatrix("opacityMatrix",this.opacityTexture.getTextureMatrix())),this.reflectionTexture&&e.StandardMaterial.ReflectionTextureEnabled&&(this._microsurfaceTextureLods.x=Math.log(this.reflectionTexture.getSize().width)*Math.LOG2E,this.reflectionTexture.isCube?this._effect.setTexture("reflectionCubeSampler",this.reflectionTexture):this._effect.setTexture("reflection2DSampler",this.reflectionTexture),this._effect.setMatrix("reflectionMatrix",this.reflectionTexture.getReflectionTextureMatrix()),this._effect.setFloat2("vReflectionInfos",this.reflectionTexture.level,0),this._defines.USESPHERICALFROMREFLECTIONMAP&&(this._effect.setFloat3("vSphericalX",this.reflectionTexture.sphericalPolynomial.x.x,this.reflectionTexture.sphericalPolynomial.x.y,this.reflectionTexture.sphericalPolynomial.x.z),this._effect.setFloat3("vSphericalY",this.reflectionTexture.sphericalPolynomial.y.x,this.reflectionTexture.sphericalPolynomial.y.y,this.reflectionTexture.sphericalPolynomial.y.z),this._effect.setFloat3("vSphericalZ",this.reflectionTexture.sphericalPolynomial.z.x,this.reflectionTexture.sphericalPolynomial.z.y,this.reflectionTexture.sphericalPolynomial.z.z),this._effect.setFloat3("vSphericalXX",this.reflectionTexture.sphericalPolynomial.xx.x,this.reflectionTexture.sphericalPolynomial.xx.y,this.reflectionTexture.sphericalPolynomial.xx.z),this._effect.setFloat3("vSphericalYY",this.reflectionTexture.sphericalPolynomial.yy.x,this.reflectionTexture.sphericalPolynomial.yy.y,this.reflectionTexture.sphericalPolynomial.yy.z),this._effect.setFloat3("vSphericalZZ",this.reflectionTexture.sphericalPolynomial.zz.x,this.reflectionTexture.sphericalPolynomial.zz.y,this.reflectionTexture.sphericalPolynomial.zz.z),this._effect.setFloat3("vSphericalXY",this.reflectionTexture.sphericalPolynomial.xy.x,this.reflectionTexture.sphericalPolynomial.xy.y,this.reflectionTexture.sphericalPolynomial.xy.z),this._effect.setFloat3("vSphericalYZ",this.reflectionTexture.sphericalPolynomial.yz.x,this.reflectionTexture.sphericalPolynomial.yz.y,this.reflectionTexture.sphericalPolynomial.yz.z),this._effect.setFloat3("vSphericalZX",this.reflectionTexture.sphericalPolynomial.zx.x,this.reflectionTexture.sphericalPolynomial.zx.y,this.reflectionTexture.sphericalPolynomial.zx.z))),this.emissiveTexture&&e.StandardMaterial.EmissiveTextureEnabled&&(this._effect.setTexture("emissiveSampler",this.emissiveTexture),this._effect.setFloat2("vEmissiveInfos",this.emissiveTexture.coordinatesIndex,this.emissiveTexture.level),this._effect.setMatrix("emissiveMatrix",this.emissiveTexture.getTextureMatrix())),this.lightmapTexture&&e.StandardMaterial.LightmapTextureEnabled&&(this._effect.setTexture("lightmapSampler",this.lightmapTexture),this._effect.setFloat2("vLightmapInfos",this.lightmapTexture.coordinatesIndex,this.lightmapTexture.level),this._effect.setMatrix("lightmapMatrix",this.lightmapTexture.getTextureMatrix())),this.reflectivityTexture&&e.StandardMaterial.SpecularTextureEnabled&&(this._effect.setTexture("reflectivitySampler",this.reflectivityTexture),this._effect.setFloat2("vReflectivityInfos",this.reflectivityTexture.coordinatesIndex,this.reflectivityTexture.level),this._effect.setMatrix("reflectivityMatrix",this.reflectivityTexture.getTextureMatrix())),this.bumpTexture&&this._myScene.getEngine().getCaps().standardDerivatives&&e.StandardMaterial.BumpTextureEnabled&&!this.disableBumpMap&&(this._effect.setTexture("bumpSampler",this.bumpTexture),this._effect.setFloat2("vBumpInfos",this.bumpTexture.coordinatesIndex,1/this.bumpTexture.level),this._effect.setMatrix("bumpMatrix",this.bumpTexture.getTextureMatrix())),this.refractionTexture&&e.StandardMaterial.RefractionTextureEnabled){this._microsurfaceTextureLods.y=Math.log(this.refractionTexture.getSize().width)*Math.LOG2E;var r=1;this.refractionTexture.isCube?this._effect.setTexture("refractionCubeSampler",this.refractionTexture):(this._effect.setTexture("refraction2DSampler",this.refractionTexture),this._effect.setMatrix("refractionMatrix",this.refractionTexture.getReflectionTextureMatrix()),this.refractionTexture.depth&&(r=this.refractionTexture.depth)),this._effect.setFloat4("vRefractionInfos",this.refractionTexture.level,this.indexOfRefraction,r,this.invertRefractionY?-1:1)}(this.reflectionTexture||this.refractionTexture)&&this._myScene.getEngine().getCaps().textureLOD&&this._effect.setFloat2("vMicrosurfaceTextureLods",this._microsurfaceTextureLods.x,this._microsurfaceTextureLods.y)}e.MaterialHelper.BindClipPlane(this._effect,this._myScene),this.pointsCloud&&this._effect.setFloat("pointSize",this.pointSize),this._myScene.ambientColor.multiplyToRef(this.ambientColor,this._globalAmbientColor),this.convertColorToLinearSpaceToRef(this.reflectivityColor,o._scaledReflectivity),this._effect.setVector3("vEyePosition",this._myScene._mirroredCameraPosition?this._myScene._mirroredCameraPosition:this._myScene.activeCamera.position),this._effect.setColor3("vAmbientColor",this._globalAmbientColor),this._effect.setColor4("vReflectivityColor",o._scaledReflectivity,this.microSurface),this.convertColorToLinearSpaceToRef(this.emissiveColor,o._scaledEmissive),this._effect.setColor3("vEmissiveColor",o._scaledEmissive),this.convertColorToLinearSpaceToRef(this.reflectionColor,o._scaledReflection),this._effect.setColor3("vReflectionColor",o._scaledReflection)}this._myScene.getCachedMaterial()===this&&this.isFrozen||(this.convertColorToLinearSpaceToRef(this.albedoColor,o._scaledAlbedo),this._effect.setColor4("vAlbedoColor",o._scaledAlbedo,this.alpha*n.visibility),this._myScene.lightsEnabled&&!this.disableLighting&&o.BindLights(this._myScene,n,this._effect,this._defines,this.useScalarInLinearSpace),(this._myScene.fogEnabled&&n.applyFog&&this._myScene.fogMode!==e.Scene.FOGMODE_NONE||this.reflectionTexture)&&this._effect.setMatrix("view",this._myScene.getViewMatrix()),e.MaterialHelper.BindFogParameters(this._myScene,n,this._effect),this._lightingInfos.x=this.directIntensity,this._lightingInfos.y=this.emissiveIntensity,this._lightingInfos.z=this.environmentIntensity,this._lightingInfos.w=this.specularIntensity,this._effect.setVector4("vLightingIntensity",this._lightingInfos),this._overloadedShadowInfos.x=this.overloadedShadowIntensity,this._overloadedShadowInfos.y=this.overloadedShadeIntensity,this._effect.setVector4("vOverloadedShadowIntensity",this._overloadedShadowInfos),this._cameraInfos.x=this.cameraExposure,this._cameraInfos.y=this.cameraContrast,this._effect.setVector4("vCameraInfos",this._cameraInfos),this._overloadedIntensity.x=this.overloadedAmbientIntensity,this._overloadedIntensity.y=this.overloadedAlbedoIntensity,this._overloadedIntensity.z=this.overloadedReflectivityIntensity,this._overloadedIntensity.w=this.overloadedEmissiveIntensity,this._effect.setVector4("vOverloadedIntensity",this._overloadedIntensity),this.convertColorToLinearSpaceToRef(this.overloadedAmbient,this._tempColor),this._effect.setColor3("vOverloadedAmbient",this._tempColor),this.convertColorToLinearSpaceToRef(this.overloadedAlbedo,this._tempColor),this._effect.setColor3("vOverloadedAlbedo",this._tempColor),this.convertColorToLinearSpaceToRef(this.overloadedReflectivity,this._tempColor),this._effect.setColor3("vOverloadedReflectivity",this._tempColor),this.convertColorToLinearSpaceToRef(this.overloadedEmissive,this._tempColor),this._effect.setColor3("vOverloadedEmissive",this._tempColor),this.convertColorToLinearSpaceToRef(this.overloadedReflection,this._tempColor),this._effect.setColor3("vOverloadedReflection",this._tempColor),this._overloadedMicroSurface.x=this.overloadedMicroSurface,this._overloadedMicroSurface.y=this.overloadedMicroSurfaceIntensity,this._overloadedMicroSurface.z=this.overloadedReflectionIntensity,this._effect.setVector3("vOverloadedMicroSurface",this._overloadedMicroSurface),e.MaterialHelper.BindLogDepth(this._defines,this._effect,this._myScene)),t.prototype.bind.call(this,i,n),this._myScene=null},o.prototype.getAnimatables=function(){var e=[];return this.albedoTexture&&this.albedoTexture.animations&&this.albedoTexture.animations.length>0&&e.push(this.albedoTexture),this.ambientTexture&&this.ambientTexture.animations&&this.ambientTexture.animations.length>0&&e.push(this.ambientTexture),this.opacityTexture&&this.opacityTexture.animations&&this.opacityTexture.animations.length>0&&e.push(this.opacityTexture),this.reflectionTexture&&this.reflectionTexture.animations&&this.reflectionTexture.animations.length>0&&e.push(this.reflectionTexture),this.emissiveTexture&&this.emissiveTexture.animations&&this.emissiveTexture.animations.length>0&&e.push(this.emissiveTexture),this.reflectivityTexture&&this.reflectivityTexture.animations&&this.reflectivityTexture.animations.length>0&&e.push(this.reflectivityTexture),this.bumpTexture&&this.bumpTexture.animations&&this.bumpTexture.animations.length>0&&e.push(this.bumpTexture),this.lightmapTexture&&this.lightmapTexture.animations&&this.lightmapTexture.animations.length>0&&e.push(this.lightmapTexture),this.refractionTexture&&this.refractionTexture.animations&&this.refractionTexture.animations.length>0&&e.push(this.refractionTexture),e},o.prototype.dispose=function(e){this.albedoTexture&&this.albedoTexture.dispose(),this.ambientTexture&&this.ambientTexture.dispose(),this.opacityTexture&&this.opacityTexture.dispose(),this.reflectionTexture&&this.reflectionTexture.dispose(),this.emissiveTexture&&this.emissiveTexture.dispose(),this.reflectivityTexture&&this.reflectivityTexture.dispose(),this.bumpTexture&&this.bumpTexture.dispose(),this.lightmapTexture&&this.lightmapTexture.dispose(),this.refractionTexture&&this.refractionTexture.dispose(),t.prototype.dispose.call(this,e)},o.prototype.clone=function(i){var n=this;return e.SerializationHelper.Clone(function(){return new o(i,n.getScene())},this)},o.prototype.serialize=function(){var i=e.SerializationHelper.Serialize(this);return i.customType="BABYLON.PBRMaterial",i},o.Parse=function(i,n,t){return e.SerializationHelper.Parse(function(){return new o(i.name,n)},i,n,t)},o._scaledAlbedo=new e.Color3,o._scaledReflectivity=new e.Color3,o._scaledEmissive=new e.Color3,o._scaledReflection=new e.Color3,o._lightRadiuses=[1,1,1,1],__decorate([e.serialize()],o.prototype,"directIntensity"),__decorate([e.serialize()],o.prototype,"emissiveIntensity"),__decorate([e.serialize()],o.prototype,"environmentIntensity"),__decorate([e.serialize()],o.prototype,"specularIntensity"),__decorate([e.serialize()],o.prototype,"overloadedShadowIntensity"),__decorate([e.serialize()],o.prototype,"overloadedShadeIntensity"),__decorate([e.serialize()],o.prototype,"cameraExposure"),__decorate([e.serialize()],o.prototype,"cameraContrast"),__decorate([e.serialize()],o.prototype,"overloadedAmbientIntensity"),__decorate([e.serialize()],o.prototype,"overloadedAlbedoIntensity"),__decorate([e.serialize()],o.prototype,"overloadedReflectivityIntensity"),__decorate([e.serialize()],o.prototype,"overloadedEmissiveIntensity"),__decorate([e.serializeAsColor3()],o.prototype,"overloadedAmbient"),__decorate([e.serializeAsColor3()],o.prototype,"overloadedAlbedo"),__decorate([e.serializeAsColor3()],o.prototype,"overloadedReflectivity"),__decorate([e.serializeAsColor3()],o.prototype,"overloadedEmissive"),__decorate([e.serializeAsColor3()],o.prototype,"overloadedReflection"),__decorate([e.serialize()],o.prototype,"overloadedMicroSurface"),__decorate([e.serialize()],o.prototype,"overloadedMicroSurfaceIntensity"),__decorate([e.serialize()],o.prototype,"overloadedReflectionIntensity"),__decorate([e.serialize()],o.prototype,"disableBumpMap"),__decorate([e.serializeAsTexture()],o.prototype,"albedoTexture"),__decorate([e.serializeAsTexture()],o.prototype,"ambientTexture"),__decorate([e.serializeAsTexture()],o.prototype,"opacityTexture"),__decorate([e.serializeAsTexture()],o.prototype,"reflectionTexture"),__decorate([e.serializeAsTexture()],o.prototype,"emissiveTexture"),__decorate([e.serializeAsTexture()],o.prototype,"reflectivityTexture"),__decorate([e.serializeAsTexture()],o.prototype,"bumpTexture"),__decorate([e.serializeAsTexture()],o.prototype,"lightmapTexture"),__decorate([e.serializeAsTexture()],o.prototype,"refractionTexture"),__decorate([e.serializeAsColor3("ambient")],o.prototype,"ambientColor"),__decorate([e.serializeAsColor3("albedo")],o.prototype,"albedoColor"),__decorate([e.serializeAsColor3("reflectivity")],o.prototype,"reflectivityColor"),__decorate([e.serializeAsColor3("reflection")],o.prototype,"reflectionColor"),__decorate([e.serializeAsColor3("emissivie")],o.prototype,"emissiveColor"),__decorate([e.serialize()],o.prototype,"microSurface"),__decorate([e.serialize()],o.prototype,"indexOfRefraction"),__decorate([e.serialize()],o.prototype,"invertRefractionY"),__decorate([e.serializeAsFresnelParameters()],o.prototype,"opacityFresnelParameters"),__decorate([e.serializeAsFresnelParameters()],o.prototype,"emissiveFresnelParameters"),__decorate([e.serialize()],o.prototype,"linkRefractionWithTransparency"),__decorate([e.serialize()],o.prototype,"linkEmissiveWithAlbedo"),__decorate([e.serialize()],o.prototype,"useLightmapAsShadowmap"),__decorate([e.serialize()],o.prototype,"useEmissiveAsIllumination"),__decorate([e.serialize()],o.prototype,"useAlphaFromAlbedoTexture"),__decorate([e.serialize()],o.prototype,"useSpecularOverAlpha"),__decorate([e.serialize()],o.prototype,"useMicroSurfaceFromReflectivityMapAlpha"),__decorate([e.serialize()],o.prototype,"useAutoMicroSurfaceFromReflectivityMap"),__decorate([e.serialize()],o.prototype,"useScalarInLinearSpace"),__decorate([e.serialize()],o.prototype,"usePhysicalLightFalloff"),__decorate([e.serialize()],o.prototype,"useRadianceOverAlpha"),__decorate([e.serialize()],o.prototype,"disableLighting"),Object.defineProperty(o.prototype,"useLogarithmicDepth",__decorate([e.serialize()],o.prototype,"useLogarithmicDepth",Object.getOwnPropertyDescriptor(o.prototype,"useLogarithmicDepth"))),
o}(e.Material);e.PBRMaterial=t}(BABYLON||(BABYLON={})),BABYLON.Effect.ShadersStore.pbrVertexShader="precision highp float;\n\nattribute vec3 position;\n#ifdef NORMAL\nattribute vec3 normal;\n#endif\n#ifdef UV1\nattribute vec2 uv;\n#endif\n#ifdef UV2\nattribute vec2 uv2;\n#endif\n#ifdef VERTEXCOLOR\nattribute vec4 color;\n#endif\n#include<bonesDeclaration>\n\n#include<instancesDeclaration>\nuniform mat4 view;\nuniform mat4 viewProjection;\n#ifdef ALBEDO\nvarying vec2 vAlbedoUV;\nuniform mat4 albedoMatrix;\nuniform vec2 vAlbedoInfos;\n#endif\n#ifdef AMBIENT\nvarying vec2 vAmbientUV;\nuniform mat4 ambientMatrix;\nuniform vec2 vAmbientInfos;\n#endif\n#ifdef OPACITY\nvarying vec2 vOpacityUV;\nuniform mat4 opacityMatrix;\nuniform vec2 vOpacityInfos;\n#endif\n#ifdef EMISSIVE\nvarying vec2 vEmissiveUV;\nuniform vec2 vEmissiveInfos;\nuniform mat4 emissiveMatrix;\n#endif\n#ifdef LIGHTMAP\nvarying vec2 vLightmapUV;\nuniform vec2 vLightmapInfos;\nuniform mat4 lightmapMatrix;\n#endif\n#if defined(REFLECTIVITY)\nvarying vec2 vReflectivityUV;\nuniform vec2 vReflectivityInfos;\nuniform mat4 reflectivityMatrix;\n#endif\n#ifdef BUMP\nvarying vec2 vBumpUV;\nuniform vec2 vBumpInfos;\nuniform mat4 bumpMatrix;\n#endif\n#ifdef POINTSIZE\nuniform float pointSize;\n#endif\n\nvarying vec3 vPositionW;\n#ifdef NORMAL\nvarying vec3 vNormalW;\n#endif\n#ifdef VERTEXCOLOR\nvarying vec4 vColor;\n#endif\n#include<clipPlaneVertexDeclaration>\n#include<fogVertexDeclaration>\n#include<shadowsVertexDeclaration>\n#ifdef REFLECTIONMAP_SKYBOX\nvarying vec3 vPositionUVW;\n#endif\n#ifdef REFLECTIONMAP_EQUIRECTANGULAR_FIXED\nvarying vec3 vDirectionW;\n#endif\n#include<logDepthDeclaration>\nvoid main(void) {\n#ifdef REFLECTIONMAP_SKYBOX\n vPositionUVW = position;\n#endif \n#include<instancesVertex>\n#include<bonesVertex>\n gl_Position = viewProjection * finalWorld * vec4(position, 1.0);\n vec4 worldPos = finalWorld * vec4(position, 1.0);\n vPositionW = vec3(worldPos);\n#ifdef NORMAL\n vNormalW = normalize(vec3(finalWorld * vec4(normal, 0.0)));\n#endif\n#ifdef REFLECTIONMAP_EQUIRECTANGULAR_FIXED\n vDirectionW = normalize(vec3(finalWorld * vec4(position, 0.0)));\n#endif\n \n#ifndef UV1\n vec2 uv = vec2(0., 0.);\n#endif\n#ifndef UV2\n vec2 uv2 = vec2(0., 0.);\n#endif\n#ifdef ALBEDO\n if (vAlbedoInfos.x == 0.)\n {\n vAlbedoUV = vec2(albedoMatrix * vec4(uv, 1.0, 0.0));\n }\n else\n {\n vAlbedoUV = vec2(albedoMatrix * vec4(uv2, 1.0, 0.0));\n }\n#endif\n#ifdef AMBIENT\n if (vAmbientInfos.x == 0.)\n {\n vAmbientUV = vec2(ambientMatrix * vec4(uv, 1.0, 0.0));\n }\n else\n {\n vAmbientUV = vec2(ambientMatrix * vec4(uv2, 1.0, 0.0));\n }\n#endif\n#ifdef OPACITY\n if (vOpacityInfos.x == 0.)\n {\n vOpacityUV = vec2(opacityMatrix * vec4(uv, 1.0, 0.0));\n }\n else\n {\n vOpacityUV = vec2(opacityMatrix * vec4(uv2, 1.0, 0.0));\n }\n#endif\n#ifdef EMISSIVE\n if (vEmissiveInfos.x == 0.)\n {\n vEmissiveUV = vec2(emissiveMatrix * vec4(uv, 1.0, 0.0));\n }\n else\n {\n vEmissiveUV = vec2(emissiveMatrix * vec4(uv2, 1.0, 0.0));\n }\n#endif\n#ifdef LIGHTMAP\n if (vLightmapInfos.x == 0.)\n {\n vLightmapUV = vec2(lightmapMatrix * vec4(uv, 1.0, 0.0));\n }\n else\n {\n vLightmapUV = vec2(lightmapMatrix * vec4(uv2, 1.0, 0.0));\n }\n#endif\n#if defined(REFLECTIVITY)\n if (vReflectivityInfos.x == 0.)\n {\n vReflectivityUV = vec2(reflectivityMatrix * vec4(uv, 1.0, 0.0));\n }\n else\n {\n vReflectivityUV = vec2(reflectivityMatrix * vec4(uv2, 1.0, 0.0));\n }\n#endif\n#ifdef BUMP\n if (vBumpInfos.x == 0.)\n {\n vBumpUV = vec2(bumpMatrix * vec4(uv, 1.0, 0.0));\n }\n else\n {\n vBumpUV = vec2(bumpMatrix * vec4(uv2, 1.0, 0.0));\n }\n#endif\n \n#include<clipPlaneVertex>\n \n#include<fogVertex>\n \n#include<shadowsVertex>\n \n#ifdef VERTEXCOLOR\n vColor = color;\n#endif\n \n#ifdef POINTSIZE\n gl_PointSize = pointSize;\n#endif\n \n#include<logDepthVertex>\n}",BABYLON.Effect.ShadersStore.pbrPixelShader="#ifdef BUMP\n#extension GL_OES_standard_derivatives : enable\n#endif\n#ifdef LODBASEDMICROSFURACE\n#extension GL_EXT_shader_texture_lod : enable\n#endif\n#ifdef LOGARITHMICDEPTH\n#extension GL_EXT_frag_depth : enable\n#endif\nprecision highp float;\n\n#define RECIPROCAL_PI2 0.15915494\n#define FRESNEL_MAXIMUM_ON_ROUGH 0.25\nuniform vec3 vEyePosition;\nuniform vec3 vAmbientColor;\nuniform vec3 vReflectionColor;\nuniform vec4 vAlbedoColor;\nuniform vec4 vLightRadiuses;\n\nuniform vec4 vLightingIntensity;\nuniform vec4 vCameraInfos;\n#ifdef OVERLOADEDVALUES\n uniform vec4 vOverloadedIntensity;\n uniform vec3 vOverloadedAmbient;\n uniform vec3 vOverloadedAlbedo;\n uniform vec3 vOverloadedReflectivity;\n uniform vec3 vOverloadedEmissive;\n uniform vec3 vOverloadedReflection;\n uniform vec3 vOverloadedMicroSurface;\n#endif\n#ifdef OVERLOADEDSHADOWVALUES\n uniform vec4 vOverloadedShadowIntensity;\n#endif\n#ifdef USESPHERICALFROMREFLECTIONMAP\n uniform vec3 vSphericalX;\n uniform vec3 vSphericalY;\n uniform vec3 vSphericalZ;\n uniform vec3 vSphericalXX;\n uniform vec3 vSphericalYY;\n uniform vec3 vSphericalZZ;\n uniform vec3 vSphericalXY;\n uniform vec3 vSphericalYZ;\n uniform vec3 vSphericalZX;\n vec3 EnvironmentIrradiance(vec3 normal)\n {\n \n \n \n vec3 result =\n vSphericalX * normal.x +\n vSphericalY * normal.y +\n vSphericalZ * normal.z +\n vSphericalXX * normal.x * normal.x +\n vSphericalYY * normal.y * normal.y +\n vSphericalZZ * normal.z * normal.z +\n vSphericalYZ * normal.y * normal.z +\n vSphericalZX * normal.z * normal.x +\n vSphericalXY * normal.x * normal.y;\n return result.rgb;\n }\n#endif\n#ifdef LODBASEDMICROSFURACE\n uniform vec2 vMicrosurfaceTextureLods;\n#endif\n\nconst float kPi = 3.1415926535897932384626433832795;\nconst float kRougnhessToAlphaScale = 0.1;\nconst float kRougnhessToAlphaOffset = 0.29248125;\n#ifdef PoissonSamplingEnvironment\n const int poissonSphereSamplersCount = 32;\n vec3 poissonSphereSamplers[poissonSphereSamplersCount];\n void initSamplers()\n {\n poissonSphereSamplers[0] = vec3( -0.552198926093, 0.801049753814, -0.0322487480415 );\n poissonSphereSamplers[1] = vec3( 0.344874796559, -0.650989584719, 0.283038477033 ); \n poissonSphereSamplers[2] = vec3( -0.0710183703467, 0.163770497767, -0.95022416734 ); \n poissonSphereSamplers[3] = vec3( 0.422221832073, 0.576613638193, 0.519157625948 ); \n poissonSphereSamplers[4] = vec3( -0.561872200916, -0.665581249881, -0.131630473211 ); \n poissonSphereSamplers[5] = vec3( -0.409905973809, 0.0250731510778, 0.674676954809 ); \n poissonSphereSamplers[6] = vec3( 0.206829570551, -0.190199352704, 0.919073906156 ); \n poissonSphereSamplers[7] = vec3( -0.857514664463, 0.0274425010091, -0.475068738967 ); \n poissonSphereSamplers[8] = vec3( -0.816275009951, -0.0432916479141, 0.40394579291 ); \n poissonSphereSamplers[9] = vec3( 0.397976181928, -0.633227519667, -0.617794410447 ); \n poissonSphereSamplers[10] = vec3( -0.181484199014, 0.0155418272003, -0.34675720703 ); \n poissonSphereSamplers[11] = vec3( 0.591734926919, 0.489930882201, -0.51675303188 ); \n poissonSphereSamplers[12] = vec3( -0.264514973057, 0.834248662136, 0.464624235985 ); \n poissonSphereSamplers[13] = vec3( -0.125845223505, 0.812029586099, -0.46213797731 ); \n poissonSphereSamplers[14] = vec3( 0.0345715424639, 0.349983742938, 0.855109899027 ); \n poissonSphereSamplers[15] = vec3( 0.694340492749, -0.281052190209, -0.379600605543 ); \n poissonSphereSamplers[16] = vec3( -0.241055518078, -0.580199280578, 0.435381168431 );\n poissonSphereSamplers[17] = vec3( 0.126313722289, 0.715113642744, 0.124385788055 ); \n poissonSphereSamplers[18] = vec3( 0.752862552387, 0.277075021888, 0.275059597549 );\n poissonSphereSamplers[19] = vec3( -0.400896300918, -0.309374534321, -0.74285782627 ); \n poissonSphereSamplers[20] = vec3( 0.121843331941, -0.00381197918195, 0.322441835258 ); \n poissonSphereSamplers[21] = vec3( 0.741656771351, -0.472083016745, 0.14589173819 ); \n poissonSphereSamplers[22] = vec3( -0.120347565985, -0.397252703556, -0.00153836114051 ); \n poissonSphereSamplers[23] = vec3( -0.846258835203, -0.433763808754, 0.168732209784 ); \n poissonSphereSamplers[24] = vec3( 0.257765618362, -0.546470581239, -0.242234375624 ); \n poissonSphereSamplers[25] = vec3( -0.640343473361, 0.51920903395, 0.549310644325 ); \n poissonSphereSamplers[26] = vec3( -0.894309984621, 0.297394061018, 0.0884583225292 ); \n poissonSphereSamplers[27] = vec3( -0.126241933628, -0.535151016335, -0.440093659672 ); \n poissonSphereSamplers[28] = vec3( -0.158176440297, -0.393125021578, 0.890727226039 ); \n poissonSphereSamplers[29] = vec3( 0.896024272938, 0.203068725821, -0.11198597748 ); \n poissonSphereSamplers[30] = vec3( 0.568671758933, -0.314144243629, 0.509070768816 ); \n poissonSphereSamplers[31] = vec3( 0.289665332178, 0.104356977462, -0.348379247171 );\n }\n vec3 environmentSampler(samplerCube cubeMapSampler, vec3 centralDirection, float microsurfaceAverageSlope)\n {\n vec3 result = vec3(0., 0., 0.);\n for(int i = 0; i < poissonSphereSamplersCount; i++)\n {\n vec3 offset = poissonSphereSamplers[i];\n vec3 direction = centralDirection + microsurfaceAverageSlope * offset;\n result += textureCube(cubeMapSampler, direction, 0.).rgb;\n }\n result /= 32.0;\n return result;\n }\n#endif\n\nfloat Square(float value)\n{\n return value * value;\n}\nfloat getLuminance(vec3 color)\n{\n return clamp(dot(color, vec3(0.2126, 0.7152, 0.0722)), 0., 1.);\n}\nfloat convertRoughnessToAverageSlope(float roughness)\n{\n \n const float kMinimumVariance = 0.0005;\n float alphaG = Square(roughness) + kMinimumVariance;\n return alphaG;\n}\n\nfloat getMipMapIndexFromAverageSlope(float maxMipLevel, float alpha)\n{\n \n \n \n \n \n \n \n float mip = kRougnhessToAlphaOffset + maxMipLevel + (maxMipLevel * kRougnhessToAlphaScale * log2(alpha));\n return clamp(mip, 0., maxMipLevel);\n}\n\nfloat smithVisibilityG1_TrowbridgeReitzGGX(float dot, float alphaG)\n{\n float tanSquared = (1.0 - dot * dot) / (dot * dot);\n return 2.0 / (1.0 + sqrt(1.0 + alphaG * alphaG * tanSquared));\n}\nfloat smithVisibilityG_TrowbridgeReitzGGX_Walter(float NdotL, float NdotV, float alphaG)\n{\n return smithVisibilityG1_TrowbridgeReitzGGX(NdotL, alphaG) * smithVisibilityG1_TrowbridgeReitzGGX(NdotV, alphaG);\n}\n\n\nfloat normalDistributionFunction_TrowbridgeReitzGGX(float NdotH, float alphaG)\n{\n \n \n \n float a2 = Square(alphaG);\n float d = NdotH * NdotH * (a2 - 1.0) + 1.0;\n return a2 / (kPi * d * d);\n}\nvec3 fresnelSchlickGGX(float VdotH, vec3 reflectance0, vec3 reflectance90)\n{\n return reflectance0 + (reflectance90 - reflectance0) * pow(clamp(1.0 - VdotH, 0., 1.), 5.0);\n}\nvec3 FresnelSchlickEnvironmentGGX(float VdotN, vec3 reflectance0, vec3 reflectance90, float smoothness)\n{\n \n float weight = mix(FRESNEL_MAXIMUM_ON_ROUGH, 1.0, smoothness);\n return reflectance0 + weight * (reflectance90 - reflectance0) * pow(clamp(1.0 - VdotN, 0., 1.), 5.0);\n}\n\nvec3 computeSpecularTerm(float NdotH, float NdotL, float NdotV, float VdotH, float roughness, vec3 specularColor)\n{\n float alphaG = convertRoughnessToAverageSlope(roughness);\n float distribution = normalDistributionFunction_TrowbridgeReitzGGX(NdotH, alphaG);\n float visibility = smithVisibilityG_TrowbridgeReitzGGX_Walter(NdotL, NdotV, alphaG);\n visibility /= (4.0 * NdotL * NdotV); \n vec3 fresnel = fresnelSchlickGGX(VdotH, specularColor, vec3(1., 1., 1.));\n float specTerm = max(0., visibility * distribution) * NdotL;\n return fresnel * specTerm * kPi; \n}\nfloat computeDiffuseTerm(float NdotL, float NdotV, float VdotH, float roughness)\n{\n \n \n float diffuseFresnelNV = pow(clamp(1.0 - NdotL, 0.000001, 1.), 5.0);\n float diffuseFresnelNL = pow(clamp(1.0 - NdotV, 0.000001, 1.), 5.0);\n float diffuseFresnel90 = 0.5 + 2.0 * VdotH * VdotH * roughness;\n float diffuseFresnelTerm =\n (1.0 + (diffuseFresnel90 - 1.0) * diffuseFresnelNL) *\n (1.0 + (diffuseFresnel90 - 1.0) * diffuseFresnelNV);\n return diffuseFresnelTerm * NdotL;\n \n \n}\nfloat adjustRoughnessFromLightProperties(float roughness, float lightRadius, float lightDistance)\n{\n \n float lightRoughness = lightRadius / lightDistance;\n \n float totalRoughness = clamp(lightRoughness + roughness, 0., 1.);\n return totalRoughness;\n}\nfloat computeDefaultMicroSurface(float microSurface, vec3 reflectivityColor)\n{\n float kReflectivityNoAlphaWorkflow_SmoothnessMax = 0.95;\n float reflectivityLuminance = getLuminance(reflectivityColor);\n float reflectivityLuma = sqrt(reflectivityLuminance);\n microSurface = reflectivityLuma * kReflectivityNoAlphaWorkflow_SmoothnessMax;\n return microSurface;\n}\nvec3 toLinearSpace(vec3 color)\n{\n return vec3(pow(color.r, 2.2), pow(color.g, 2.2), pow(color.b, 2.2));\n}\nvec3 toGammaSpace(vec3 color)\n{\n return vec3(pow(color.r, 1.0 / 2.2), pow(color.g, 1.0 / 2.2), pow(color.b, 1.0 / 2.2));\n}\nfloat computeLightFalloff(vec3 lightOffset, float lightDistanceSquared, float range)\n{\n #ifdef USEPHYSICALLIGHTFALLOFF\n float lightDistanceFalloff = 1.0 / ((lightDistanceSquared + 0.0001));\n return lightDistanceFalloff;\n #else\n float lightFalloff = max(0., 1.0 - length(lightOffset) / range);\n return lightFalloff;\n #endif\n}\n#ifdef CAMERATONEMAP\n vec3 toneMaps(vec3 color)\n {\n color = max(color, 0.0);\n \n color.rgb = color.rgb * vCameraInfos.x;\n float tuning = 1.5; \n \n \n vec3 tonemapped = 1.0 - exp2(-color.rgb * tuning); \n color.rgb = mix(color.rgb, tonemapped, 1.0);\n return color;\n }\n#endif\n#ifdef CAMERACONTRAST\n vec4 contrasts(vec4 color)\n {\n color = clamp(color, 0.0, 1.0);\n vec3 resultHighContrast = color.rgb * color.rgb * (3.0 - 2.0 * color.rgb);\n float contrast = vCameraInfos.y;\n if (contrast < 1.0)\n {\n \n color.rgb = mix(vec3(0.5, 0.5, 0.5), color.rgb, contrast);\n }\n else\n {\n \n color.rgb = mix(color.rgb, resultHighContrast, contrast - 1.0);\n }\n return color;\n }\n#endif\n\n uniform vec4 vReflectivityColor;\n uniform vec3 vEmissiveColor;\n\nvarying vec3 vPositionW;\n#ifdef NORMAL\nvarying vec3 vNormalW;\n#endif\n#ifdef VERTEXCOLOR\nvarying vec4 vColor;\n#endif\n\n#include<light0FragmentDeclaration>\n#include<light1FragmentDeclaration>\n#include<light2FragmentDeclaration>\n#include<light3FragmentDeclaration>\n\n#ifdef ALBEDO\nvarying vec2 vAlbedoUV;\nuniform sampler2D albedoSampler;\nuniform vec2 vAlbedoInfos;\n#endif\n#ifdef AMBIENT\nvarying vec2 vAmbientUV;\nuniform sampler2D ambientSampler;\nuniform vec2 vAmbientInfos;\n#endif\n#ifdef OPACITY \nvarying vec2 vOpacityUV;\nuniform sampler2D opacitySampler;\nuniform vec2 vOpacityInfos;\n#endif\n#ifdef EMISSIVE\nvarying vec2 vEmissiveUV;\nuniform vec2 vEmissiveInfos;\nuniform sampler2D emissiveSampler;\n#endif\n#ifdef LIGHTMAP\nvarying vec2 vLightmapUV;\nuniform vec2 vLightmapInfos;\nuniform sampler2D lightmapSampler;\n#endif\n#if defined(REFLECTIVITY)\nvarying vec2 vReflectivityUV;\nuniform vec2 vReflectivityInfos;\nuniform sampler2D reflectivitySampler;\n#endif\n\n#include<fresnelFunction>\n#ifdef OPACITYFRESNEL\nuniform vec4 opacityParts;\n#endif\n#ifdef EMISSIVEFRESNEL\nuniform vec4 emissiveLeftColor;\nuniform vec4 emissiveRightColor;\n#endif\n\n#if defined(REFLECTIONMAP_SPHERICAL) || defined(REFLECTIONMAP_PROJECTION) || defined(REFRACTION)\n uniform mat4 view;\n#endif\n\n#ifdef REFRACTION\n uniform vec4 vRefractionInfos;\n #ifdef REFRACTIONMAP_3D\n uniform samplerCube refractionCubeSampler;\n #else\n uniform sampler2D refraction2DSampler;\n uniform mat4 refractionMatrix;\n #endif\n#endif\n\n#ifdef REFLECTION\nuniform vec2 vReflectionInfos;\n#ifdef REFLECTIONMAP_3D\nuniform samplerCube reflectionCubeSampler;\n#else\nuniform sampler2D reflection2DSampler;\n#endif\n#ifdef REFLECTIONMAP_SKYBOX\nvarying vec3 vPositionUVW;\n#else\n #ifdef REFLECTIONMAP_EQUIRECTANGULAR_FIXED\n varying vec3 vDirectionW;\n #endif\n #if defined(REFLECTIONMAP_PLANAR) || defined(REFLECTIONMAP_CUBIC) || defined(REFLECTIONMAP_PROJECTION)\n uniform mat4 reflectionMatrix;\n #endif\n#endif\n#include<reflectionFunction>\n#endif\n\n#ifdef SHADOWS\nfloat unpack(vec4 color)\n{\n const vec4 bit_shift = vec4(1.0 / (255.0 * 255.0 * 255.0), 1.0 / (255.0 * 255.0), 1.0 / 255.0, 1.0);\n return dot(color, bit_shift);\n}\n#if defined(POINTLIGHT0) || defined(POINTLIGHT1) || defined(POINTLIGHT2) || defined(POINTLIGHT3)\nuniform vec2 depthValues;\nfloat computeShadowCube(vec3 lightPosition, samplerCube shadowSampler, float darkness, float bias)\n{\n vec3 directionToLight = vPositionW - lightPosition;\n float depth = length(directionToLight);\n depth = clamp(depth, 0., 1.0);\n directionToLight = normalize(directionToLight);\n directionToLight.y = - directionToLight.y;\n float shadow = unpack(textureCube(shadowSampler, directionToLight)) + bias;\n if (depth > shadow)\n {\n#ifdef OVERLOADEDSHADOWVALUES\n return mix(1.0, darkness, vOverloadedShadowIntensity.x);\n#else\n return darkness;\n#endif\n }\n return 1.0;\n}\nfloat computeShadowWithPCFCube(vec3 lightPosition, samplerCube shadowSampler, float mapSize, float bias, float darkness)\n{\n vec3 directionToLight = vPositionW - lightPosition;\n float depth = length(directionToLight);\n depth = (depth - depthValues.x) / (depthValues.y - depthValues.x);\n depth = clamp(depth, 0., 1.0);\n directionToLight = normalize(directionToLight);\n directionToLight.y = -directionToLight.y;\n float visibility = 1.;\n vec3 poissonDisk[4];\n poissonDisk[0] = vec3(-1.0, 1.0, -1.0);\n poissonDisk[1] = vec3(1.0, -1.0, -1.0);\n poissonDisk[2] = vec3(-1.0, -1.0, -1.0);\n poissonDisk[3] = vec3(1.0, -1.0, 1.0);\n \n float biasedDepth = depth - bias;\n if (unpack(textureCube(shadowSampler, directionToLight + poissonDisk[0] * mapSize)) < biasedDepth) visibility -= 0.25;\n if (unpack(textureCube(shadowSampler, directionToLight + poissonDisk[1] * mapSize)) < biasedDepth) visibility -= 0.25;\n if (unpack(textureCube(shadowSampler, directionToLight + poissonDisk[2] * mapSize)) < biasedDepth) visibility -= 0.25;\n if (unpack(textureCube(shadowSampler, directionToLight + poissonDisk[3] * mapSize)) < biasedDepth) visibility -= 0.25;\n#ifdef OVERLOADEDSHADOWVALUES\n return min(1.0, mix(1.0, visibility + darkness, vOverloadedShadowIntensity.x));\n#else\n return min(1.0, visibility + darkness);\n#endif\n}\n#endif\n#if defined(SPOTLIGHT0) || defined(SPOTLIGHT1) || defined(SPOTLIGHT2) || defined(SPOTLIGHT3) || defined(DIRLIGHT0) || defined(DIRLIGHT1) || defined(DIRLIGHT2) || defined(DIRLIGHT3)\nfloat computeShadow(vec4 vPositionFromLight, sampler2D shadowSampler, float darkness, float bias)\n{\n vec3 depth = vPositionFromLight.xyz / vPositionFromLight.w;\n depth = 0.5 * depth + vec3(0.5);\n vec2 uv = depth.xy;\n if (uv.x < 0. || uv.x > 1.0 || uv.y < 0. || uv.y > 1.0)\n {\n return 1.0;\n }\n float shadow = unpack(texture2D(shadowSampler, uv)) + bias;\n if (depth.z > shadow)\n {\n#ifdef OVERLOADEDSHADOWVALUES\n return mix(1.0, darkness, vOverloadedShadowIntensity.x);\n#else\n return darkness;\n#endif\n }\n return 1.;\n}\nfloat computeShadowWithPCF(vec4 vPositionFromLight, sampler2D shadowSampler, float mapSize, float bias, float darkness)\n{\n vec3 depth = vPositionFromLight.xyz / vPositionFromLight.w;\n depth = 0.5 * depth + vec3(0.5);\n vec2 uv = depth.xy;\n if (uv.x < 0. || uv.x > 1.0 || uv.y < 0. || uv.y > 1.0)\n {\n return 1.0;\n }\n float visibility = 1.;\n vec2 poissonDisk[4];\n poissonDisk[0] = vec2(-0.94201624, -0.39906216);\n poissonDisk[1] = vec2(0.94558609, -0.76890725);\n poissonDisk[2] = vec2(-0.094184101, -0.92938870);\n poissonDisk[3] = vec2(0.34495938, 0.29387760);\n \n float biasedDepth = depth.z - bias;\n if (unpack(texture2D(shadowSampler, uv + poissonDisk[0] * mapSize)) < biasedDepth) visibility -= 0.25;\n if (unpack(texture2D(shadowSampler, uv + poissonDisk[1] * mapSize)) < biasedDepth) visibility -= 0.25;\n if (unpack(texture2D(shadowSampler, uv + poissonDisk[2] * mapSize)) < biasedDepth) visibility -= 0.25;\n if (unpack(texture2D(shadowSampler, uv + poissonDisk[3] * mapSize)) < biasedDepth) visibility -= 0.25;\n#ifdef OVERLOADEDSHADOWVALUES\n return min(1.0, mix(1.0, visibility + darkness, vOverloadedShadowIntensity.x));\n#else\n return min(1.0, visibility + darkness);\n#endif\n}\n\nfloat unpackHalf(vec2 color)\n{\n return color.x + (color.y / 255.0);\n}\nfloat linstep(float low, float high, float v) {\n return clamp((v - low) / (high - low), 0.0, 1.0);\n}\nfloat ChebychevInequality(vec2 moments, float compare, float bias)\n{\n float p = smoothstep(compare - bias, compare, moments.x);\n float variance = max(moments.y - moments.x * moments.x, 0.02);\n float d = compare - moments.x;\n float p_max = linstep(0.2, 1.0, variance / (variance + d * d));\n return clamp(max(p, p_max), 0.0, 1.0);\n}\nfloat computeShadowWithVSM(vec4 vPositionFromLight, sampler2D shadowSampler, float bias, float darkness)\n{\n vec3 depth = vPositionFromLight.xyz / vPositionFromLight.w;\n depth = 0.5 * depth + vec3(0.5);\n vec2 uv = depth.xy;\n if (uv.x < 0. || uv.x > 1.0 || uv.y < 0. || uv.y > 1.0 || depth.z >= 1.0)\n {\n return 1.0;\n }\n vec4 texel = texture2D(shadowSampler, uv);\n vec2 moments = vec2(unpackHalf(texel.xy), unpackHalf(texel.zw));\n#ifdef OVERLOADEDSHADOWVALUES\n return min(1.0, mix(1.0, 1.0 - ChebychevInequality(moments, depth.z, bias) + darkness, vOverloadedShadowIntensity.x));\n#else\n return min(1.0, 1.0 - ChebychevInequality(moments, depth.z, bias) + darkness);\n#endif\n}\n#endif\n#endif\n#include<bumpFragmentFunctions>\n#include<clipPlaneFragmentDeclaration>\n#include<logDepthDeclaration>\n\n#include<fogFragmentDeclaration>\n\nstruct lightingInfo\n{\n vec3 diffuse;\n#ifdef SPECULARTERM\n vec3 specular;\n#endif\n};\nlightingInfo computeLighting(vec3 viewDirectionW, vec3 vNormal, vec4 lightData, vec3 diffuseColor, vec3 specularColor, float range, float roughness, float NdotV, float lightRadius) {\n lightingInfo result;\n vec3 lightDirection;\n float attenuation = 1.0;\n float lightDistance;\n \n if (lightData.w == 0.)\n {\n vec3 lightOffset = lightData.xyz - vPositionW;\n float lightDistanceSquared = dot(lightOffset, lightOffset);\n attenuation = computeLightFalloff(lightOffset, lightDistanceSquared, range);\n lightDistance = sqrt(lightDistanceSquared);\n lightDirection = normalize(lightOffset);\n }\n \n else\n {\n lightDistance = length(-lightData.xyz);\n lightDirection = normalize(-lightData.xyz);\n }\n \n roughness = adjustRoughnessFromLightProperties(roughness, lightRadius, lightDistance);\n \n vec3 H = normalize(viewDirectionW + lightDirection);\n float NdotL = max(0.00000000001, dot(vNormal, lightDirection));\n float VdotH = clamp(0.00000000001, 1.0, dot(viewDirectionW, H));\n float diffuseTerm = computeDiffuseTerm(NdotL, NdotV, VdotH, roughness);\n result.diffuse = diffuseTerm * diffuseColor * attenuation;\n#ifdef SPECULARTERM\n \n float NdotH = max(0.00000000001, dot(vNormal, H));\n vec3 specTerm = computeSpecularTerm(NdotH, NdotL, NdotV, VdotH, roughness, specularColor);\n result.specular = specTerm * attenuation;\n#endif\n return result;\n}\nlightingInfo computeSpotLighting(vec3 viewDirectionW, vec3 vNormal, vec4 lightData, vec4 lightDirection, vec3 diffuseColor, vec3 specularColor, float range, float roughness, float NdotV, float lightRadius) {\n lightingInfo result;\n vec3 lightOffset = lightData.xyz - vPositionW;\n vec3 lightVectorW = normalize(lightOffset);\n \n float cosAngle = max(0.000000000000001, dot(-lightDirection.xyz, lightVectorW));\n if (cosAngle >= lightDirection.w)\n {\n cosAngle = max(0., pow(cosAngle, lightData.w));\n \n float lightDistanceSquared = dot(lightOffset, lightOffset);\n float attenuation = computeLightFalloff(lightOffset, lightDistanceSquared, range);\n \n attenuation *= cosAngle;\n \n float lightDistance = sqrt(lightDistanceSquared);\n roughness = adjustRoughnessFromLightProperties(roughness, lightRadius, lightDistance);\n \n vec3 H = normalize(viewDirectionW - lightDirection.xyz);\n float NdotL = max(0.00000000001, dot(vNormal, -lightDirection.xyz));\n float VdotH = clamp(dot(viewDirectionW, H), 0.00000000001, 1.0);\n float diffuseTerm = computeDiffuseTerm(NdotL, NdotV, VdotH, roughness);\n result.diffuse = diffuseTerm * diffuseColor * attenuation;\n#ifdef SPECULARTERM\n \n float NdotH = max(0.00000000001, dot(vNormal, H));\n vec3 specTerm = computeSpecularTerm(NdotH, NdotL, NdotV, VdotH, roughness, specularColor);\n result.specular = specTerm * attenuation;\n#endif\n return result;\n }\n result.diffuse = vec3(0.);\n#ifdef SPECULARTERM\n result.specular = vec3(0.);\n#endif\n return result;\n}\nlightingInfo computeHemisphericLighting(vec3 viewDirectionW, vec3 vNormal, vec4 lightData, vec3 diffuseColor, vec3 specularColor, vec3 groundColor, float roughness, float NdotV, float lightRadius) {\n lightingInfo result;\n \n \n \n float ndl = dot(vNormal, lightData.xyz) * 0.5 + 0.5;\n result.diffuse = mix(groundColor, diffuseColor, ndl);\n#ifdef SPECULARTERM\n \n vec3 lightVectorW = normalize(lightData.xyz);\n vec3 H = normalize(viewDirectionW + lightVectorW);\n float NdotH = max(0.00000000001, dot(vNormal, H));\n float NdotL = max(0.00000000001, ndl);\n float VdotH = clamp(0.00000000001, 1.0, dot(viewDirectionW, H));\n vec3 specTerm = computeSpecularTerm(NdotH, NdotL, NdotV, VdotH, roughness, specularColor);\n result.specular = specTerm;\n#endif\n return result;\n}\nvoid main(void) {\n#include<clipPlaneFragment>\n #ifdef PoissonSamplingEnvironment\n initSamplers();\n #endif\n vec3 viewDirectionW = normalize(vEyePosition - vPositionW);\n \n vec4 surfaceAlbedo = vec4(1., 1., 1., 1.);\n vec3 surfaceAlbedoContribution = vAlbedoColor.rgb;\n \n float alpha = vAlbedoColor.a;\n #ifdef ALBEDO\n surfaceAlbedo = texture2D(albedoSampler, vAlbedoUV);\n surfaceAlbedo = vec4(toLinearSpace(surfaceAlbedo.rgb), surfaceAlbedo.a);\n #ifndef LINKREFRACTIONTOTRANSPARENCY\n #ifdef ALPHATEST\n if (surfaceAlbedo.a < 0.4)\n discard;\n #endif\n #endif\n #ifdef ALPHAFROMALBEDO\n alpha *= surfaceAlbedo.a;\n #endif\n surfaceAlbedo.rgb *= vAlbedoInfos.y;\n #else\n \n surfaceAlbedo.rgb = surfaceAlbedoContribution;\n surfaceAlbedoContribution = vec3(1., 1., 1.);\n #endif\n #ifdef VERTEXCOLOR\n surfaceAlbedo.rgb *= vColor.rgb;\n #endif\n #ifdef OVERLOADEDVALUES\n surfaceAlbedo.rgb = mix(surfaceAlbedo.rgb, vOverloadedAlbedo, vOverloadedIntensity.y);\n #endif\n \n #ifdef NORMAL\n vec3 normalW = normalize(vNormalW);\n #else\n vec3 normalW = vec3(1.0, 1.0, 1.0);\n #endif\n #ifdef BUMP\n mat3 TBN = cotangent_frame(vNormalW * vBumpInfos.y, -viewDirectionW, vBumpUV);\n normalW = perturbNormal(viewDirectionW, TBN, vBumpUV);\n #endif\n \n vec3 ambientColor = vec3(1., 1., 1.);\n #ifdef AMBIENT\n ambientColor = texture2D(ambientSampler, vAmbientUV).rgb * vAmbientInfos.y;\n #ifdef OVERLOADEDVALUES\n ambientColor.rgb = mix(ambientColor.rgb, vOverloadedAmbient, vOverloadedIntensity.x);\n #endif\n #endif\n \n float microSurface = vReflectivityColor.a;\n vec3 surfaceReflectivityColor = vReflectivityColor.rgb;\n #ifdef OVERLOADEDVALUES\n surfaceReflectivityColor.rgb = mix(surfaceReflectivityColor.rgb, vOverloadedReflectivity, vOverloadedIntensity.z);\n #endif\n #ifdef REFLECTIVITY\n vec4 surfaceReflectivityColorMap = texture2D(reflectivitySampler, vReflectivityUV);\n surfaceReflectivityColor = surfaceReflectivityColorMap.rgb;\n surfaceReflectivityColor = toLinearSpace(surfaceReflectivityColor);\n #ifdef OVERLOADEDVALUES\n surfaceReflectivityColor = mix(surfaceReflectivityColor, vOverloadedReflectivity, vOverloadedIntensity.z);\n #endif\n #ifdef MICROSURFACEFROMREFLECTIVITYMAP\n microSurface = surfaceReflectivityColorMap.a;\n #else\n #ifdef MICROSURFACEAUTOMATIC\n microSurface = computeDefaultMicroSurface(microSurface, surfaceReflectivityColor);\n #endif\n #endif\n #endif\n #ifdef OVERLOADEDVALUES\n microSurface = mix(microSurface, vOverloadedMicroSurface.x, vOverloadedMicroSurface.y);\n #endif\n \n float NdotV = max(0.00000000001, dot(normalW, viewDirectionW));\n \n microSurface = clamp(microSurface, 0., 1.) * 0.98;\n \n float roughness = clamp(1. - microSurface, 0.000001, 1.0);\n \n vec3 lightDiffuseContribution = vec3(0., 0., 0.);\n#ifdef OVERLOADEDSHADOWVALUES\n vec3 shadowedOnlyLightDiffuseContribution = vec3(1., 1., 1.);\n#endif\n#ifdef SPECULARTERM\n vec3 lightSpecularContribution= vec3(0., 0., 0.);\n#endif\n float notShadowLevel = 1.; \n#ifdef LIGHT0\n#ifndef SPECULARTERM\n vec3 vLightSpecular0 = vec3(0.0);\n#endif\n#ifdef SPOTLIGHT0\n lightingInfo info = computeSpotLighting(viewDirectionW, normalW, vLightData0, vLightDirection0, vLightDiffuse0.rgb, vLightSpecular0, vLightDiffuse0.a, roughness, NdotV, vLightRadiuses[0]);\n#endif\n#ifdef HEMILIGHT0\n lightingInfo info = computeHemisphericLighting(viewDirectionW, normalW, vLightData0, vLightDiffuse0.rgb, vLightSpecular0, vLightGround0, roughness, NdotV, vLightRadiuses[0]);\n#endif\n#if defined(POINTLIGHT0) || defined(DIRLIGHT0)\n lightingInfo info = computeLighting(viewDirectionW, normalW, vLightData0, vLightDiffuse0.rgb, vLightSpecular0, vLightDiffuse0.a, roughness, NdotV, vLightRadiuses[0]);\n#endif\n#ifdef SHADOW0\n#ifdef SHADOWVSM0\n notShadowLevel = computeShadowWithVSM(vPositionFromLight0, shadowSampler0, shadowsInfo0.z, shadowsInfo0.x);\n#else\n#ifdef SHADOWPCF0\n#if defined(POINTLIGHT0)\n notShadowLevel = computeShadowWithPCFCube(vLightData0.xyz, shadowSampler0, shadowsInfo0.y, shadowsInfo0.z, shadowsInfo0.x);\n#else\n notShadowLevel = computeShadowWithPCF(vPositionFromLight0, shadowSampler0, shadowsInfo0.y, shadowsInfo0.z, shadowsInfo0.x);\n#endif\n#else\n#if defined(POINTLIGHT0)\n notShadowLevel = computeShadowCube(vLightData0.xyz, shadowSampler0, shadowsInfo0.x, shadowsInfo0.z);\n#else\n notShadowLevel = computeShadow(vPositionFromLight0, shadowSampler0, shadowsInfo0.x, shadowsInfo0.z);\n#endif\n#endif\n#endif\n#else\n notShadowLevel = 1.;\n#endif\n lightDiffuseContribution += info.diffuse * notShadowLevel;\n#ifdef OVERLOADEDSHADOWVALUES\n shadowedOnlyLightDiffuseContribution *= notShadowLevel;\n#endif\n#ifdef SPECULARTERM\n lightSpecularContribution += info.specular * notShadowLevel;\n#endif\n#endif\n#ifdef LIGHT1\n#ifndef SPECULARTERM\n vec3 vLightSpecular1 = vec3(0.0);\n#endif\n#ifdef SPOTLIGHT1\n info = computeSpotLighting(viewDirectionW, normalW, vLightData1, vLightDirection1, vLightDiffuse1.rgb, vLightSpecular1, vLightDiffuse1.a, roughness, NdotV, vLightRadiuses[1]);\n#endif\n#ifdef HEMILIGHT1\n info = computeHemisphericLighting(viewDirectionW, normalW, vLightData1, vLightDiffuse1.rgb, vLightSpecular1, vLightGround1, roughness, NdotV, vLightRadiuses[1]);\n#endif\n#if defined(POINTLIGHT1) || defined(DIRLIGHT1)\n info = computeLighting(viewDirectionW, normalW, vLightData1, vLightDiffuse1.rgb, vLightSpecular1, vLightDiffuse1.a, roughness, NdotV, vLightRadiuses[1]);\n#endif\n#ifdef SHADOW1\n#ifdef SHADOWVSM1\n notShadowLevel = computeShadowWithVSM(vPositionFromLight1, shadowSampler1, shadowsInfo1.z, shadowsInfo1.x);\n#else\n#ifdef SHADOWPCF1\n#if defined(POINTLIGHT1)\n notShadowLevel = computeShadowWithPCFCube(vLightData1.xyz, shadowSampler1, shadowsInfo1.y, shadowsInfo1.z, shadowsInfo1.x);\n#else\n notShadowLevel = computeShadowWithPCF(vPositionFromLight1, shadowSampler1, shadowsInfo1.y, shadowsInfo1.z, shadowsInfo1.x);\n#endif\n#else\n#if defined(POINTLIGHT1)\n notShadowLevel = computeShadowCube(vLightData1.xyz, shadowSampler1, shadowsInfo1.x, shadowsInfo1.z);\n#else\n notShadowLevel = computeShadow(vPositionFromLight1, shadowSampler1, shadowsInfo1.x, shadowsInfo1.z);\n#endif\n#endif\n#endif\n#else\n notShadowLevel = 1.;\n#endif\n lightDiffuseContribution += info.diffuse * notShadowLevel;\n#ifdef OVERLOADEDSHADOWVALUES\n shadowedOnlyLightDiffuseContribution *= notShadowLevel;\n#endif\n#ifdef SPECULARTERM\n lightSpecularContribution += info.specular * notShadowLevel;\n#endif\n#endif\n#ifdef LIGHT2\n#ifndef SPECULARTERM\n vec3 vLightSpecular2 = vec3(0.0);\n#endif\n#ifdef SPOTLIGHT2\n info = computeSpotLighting(viewDirectionW, normalW, vLightData2, vLightDirection2, vLightDiffuse2.rgb, vLightSpecular2, vLightDiffuse2.a, roughness, NdotV, vLightRadiuses[2]);\n#endif\n#ifdef HEMILIGHT2\n info = computeHemisphericLighting(viewDirectionW, normalW, vLightData2, vLightDiffuse2.rgb, vLightSpecular2, vLightGround2, roughness, NdotV, vLightRadiuses[2]);\n#endif\n#if defined(POINTLIGHT2) || defined(DIRLIGHT2)\n info = computeLighting(viewDirectionW, normalW, vLightData2, vLightDiffuse2.rgb, vLightSpecular2, vLightDiffuse2.a, roughness, NdotV, vLightRadiuses[2]);\n#endif\n#ifdef SHADOW2\n#ifdef SHADOWVSM2\n notShadowLevel = computeShadowWithVSM(vPositionFromLight2, shadowSampler2, shadowsInfo2.z, shadowsInfo2.x);\n#else\n#ifdef SHADOWPCF2\n#if defined(POINTLIGHT2)\n notShadowLevel = computeShadowWithPCFCube(vLightData2.xyz, shadowSampler2, shadowsInfo2.y, shadowsInfo2.z, shadowsInfo2.x);\n#else\n notShadowLevel = computeShadowWithPCF(vPositionFromLight2, shadowSampler2, shadowsInfo2.y, shadowsInfo2.z, shadowsInfo2.x);\n#endif\n#else\n#if defined(POINTLIGHT2)\n notShadowLevel = computeShadowCube(vLightData2.xyz, shadowSampler2, shadowsInfo2.x, shadowsInfo2.z);\n#else\n notShadowLevel = computeShadow(vPositionFromLight2, shadowSampler2, shadowsInfo2.x, shadowsInfo2.z);\n#endif\n#endif \n#endif \n#else\n notShadowLevel = 1.;\n#endif\n lightDiffuseContribution += info.diffuse * notShadowLevel;\n#ifdef OVERLOADEDSHADOWVALUES\n shadowedOnlyLightDiffuseContribution *= notShadowLevel;\n#endif\n#ifdef SPECULARTERM\n lightSpecularContribution += info.specular * notShadowLevel;\n#endif\n#endif\n#ifdef LIGHT3\n#ifndef SPECULARTERM\n vec3 vLightSpecular3 = vec3(0.0);\n#endif\n#ifdef SPOTLIGHT3\n info = computeSpotLighting(viewDirectionW, normalW, vLightData3, vLightDirection3, vLightDiffuse3.rgb, vLightSpecular3, vLightDiffuse3.a, roughness, NdotV, vLightRadiuses[3]);\n#endif\n#ifdef HEMILIGHT3\n info = computeHemisphericLighting(viewDirectionW, normalW, vLightData3, vLightDiffuse3.rgb, vLightSpecular3, vLightGround3, roughness, NdotV, vLightRadiuses[3]);\n#endif\n#if defined(POINTLIGHT3) || defined(DIRLIGHT3)\n info = computeLighting(viewDirectionW, normalW, vLightData3, vLightDiffuse3.rgb, vLightSpecular3, vLightDiffuse3.a, roughness, NdotV, vLightRadiuses[3]);\n#endif\n#ifdef SHADOW3\n#ifdef SHADOWVSM3\n notShadowLevel = computeShadowWithVSM(vPositionFromLight3, shadowSampler3, shadowsInfo3.z, shadowsInfo3.x);\n#else\n#ifdef SHADOWPCF3\n#if defined(POINTLIGHT3)\n notShadowLevel = computeShadowWithPCFCube(vLightData3.xyz, shadowSampler3, shadowsInfo3.y, shadowsInfo3.z, shadowsInfo3.x);\n#else\n notShadowLevel = computeShadowWithPCF(vPositionFromLight3, shadowSampler3, shadowsInfo3.y, shadowsInfo3.z, shadowsInfo3.x);\n#endif\n#else\n#if defined(POINTLIGHT3)\n notShadowLevel = computeShadowCube(vLightData3.xyz, shadowSampler3, shadowsInfo3.x, shadowsInfo3.z);\n#else\n notShadowLevel = computeShadow(vPositionFromLight3, shadowSampler3, shadowsInfo3.x, shadowsInfo3.z);\n#endif\n#endif \n#endif \n#else\n notShadowLevel = 1.;\n#endif\n lightDiffuseContribution += info.diffuse * notShadowLevel;\n#ifdef OVERLOADEDSHADOWVALUES\n shadowedOnlyLightDiffuseContribution *= notShadowLevel;\n#endif\n#ifdef SPECULARTERM\n lightSpecularContribution += info.specular * notShadowLevel;\n#endif\n#endif\n#ifdef SPECULARTERM\n lightSpecularContribution *= vLightingIntensity.w;\n#endif\n#ifdef OPACITY\n vec4 opacityMap = texture2D(opacitySampler, vOpacityUV);\n #ifdef OPACITYRGB\n opacityMap.rgb = opacityMap.rgb * vec3(0.3, 0.59, 0.11);\n alpha *= (opacityMap.x + opacityMap.y + opacityMap.z)* vOpacityInfos.y;\n #else\n alpha *= opacityMap.a * vOpacityInfos.y;\n #endif\n#endif\n#ifdef VERTEXALPHA\n alpha *= vColor.a;\n#endif\n#ifdef OPACITYFRESNEL\n float opacityFresnelTerm = computeFresnelTerm(viewDirectionW, normalW, opacityParts.z, opacityParts.w);\n alpha += opacityParts.x * (1.0 - opacityFresnelTerm) + opacityFresnelTerm * opacityParts.y;\n#endif\n\nvec3 surfaceRefractionColor = vec3(0., 0., 0.);\n\n#ifdef LODBASEDMICROSFURACE\n float alphaG = convertRoughnessToAverageSlope(roughness);\n#else\n float bias = 20. * (1.0 - microSurface);\n#endif\n#ifdef REFRACTION\n vec3 refractionVector = normalize(refract(-viewDirectionW, normalW, vRefractionInfos.y));\n #ifdef LODBASEDMICROSFURACE\n float lodRefraction = getMipMapIndexFromAverageSlope(vMicrosurfaceTextureLods.y, alphaG);\n #endif\n #ifdef REFRACTIONMAP_3D\n refractionVector.y = refractionVector.y * vRefractionInfos.w;\n if (dot(refractionVector, viewDirectionW) < 1.0)\n {\n #ifdef LODBASEDMICROSFURACE\n surfaceRefractionColor = textureCubeLodEXT(refractionCubeSampler, refractionVector, lodRefraction).rgb * vRefractionInfos.x;\n #else\n surfaceRefractionColor = textureCube(refractionCubeSampler, refractionVector, bias).rgb * vRefractionInfos.x;\n #endif\n }\n #ifndef REFRACTIONMAPINLINEARSPACE\n surfaceRefractionColor = toLinearSpace(surfaceRefractionColor.rgb); \n #endif\n #else\n vec3 vRefractionUVW = vec3(refractionMatrix * (view * vec4(vPositionW + refractionVector * vRefractionInfos.z, 1.0)));\n vec2 refractionCoords = vRefractionUVW.xy / vRefractionUVW.z;\n refractionCoords.y = 1.0 - refractionCoords.y;\n #ifdef LODBASEDMICROSFURACE\n surfaceRefractionColor = texture2DLodEXT(refraction2DSampler, refractionCoords, lodRefraction).rgb * vRefractionInfos.x;\n #else\n surfaceRefractionColor = texture2D(refraction2DSampler, refractionCoords, bias).rgb * vRefractionInfos.x;\n #endif \n surfaceRefractionColor = toLinearSpace(surfaceRefractionColor.rgb); \n #endif\n#endif\n\nvec3 environmentRadiance = vReflectionColor.rgb;\nvec3 environmentIrradiance = vReflectionColor.rgb;\n#ifdef REFLECTION\n vec3 vReflectionUVW = computeReflectionCoords(vec4(vPositionW, 1.0), normalW);\n #ifdef LODBASEDMICROSFURACE\n float lodReflection = getMipMapIndexFromAverageSlope(vMicrosurfaceTextureLods.x, alphaG);\n #endif\n #ifdef REFLECTIONMAP_3D\n #ifdef LODBASEDMICROSFURACE\n environmentRadiance = textureCubeLodEXT(reflectionCubeSampler, vReflectionUVW, lodReflection).rgb * vReflectionInfos.x;\n #else\n environmentRadiance = textureCube(reflectionCubeSampler, vReflectionUVW, bias).rgb * vReflectionInfos.x;\n #endif\n #ifdef PoissonSamplingEnvironment\n environmentRadiance = environmentSampler(reflectionCubeSampler, vReflectionUVW, alphaG) * vReflectionInfos.x;\n #endif\n #ifdef USESPHERICALFROMREFLECTIONMAP\n #ifndef REFLECTIONMAP_SKYBOX\n vec3 normalEnvironmentSpace = (reflectionMatrix * vec4(normalW, 1)).xyz;\n environmentIrradiance = EnvironmentIrradiance(normalEnvironmentSpace);\n #endif\n #else\n environmentRadiance = toLinearSpace(environmentRadiance.rgb);\n environmentIrradiance = textureCube(reflectionCubeSampler, normalW, 20.).rgb * vReflectionInfos.x;\n environmentIrradiance = toLinearSpace(environmentIrradiance.rgb);\n environmentIrradiance *= 0.2; \n #endif\n #else\n vec2 coords = vReflectionUVW.xy;\n #ifdef REFLECTIONMAP_PROJECTION\n coords /= vReflectionUVW.z;\n #endif\n coords.y = 1.0 - coords.y;\n #ifdef LODBASEDMICROSFURACE\n environmentRadiance = texture2DLodEXT(reflection2DSampler, coords, lodReflection).rgb * vReflectionInfos.x;\n #else\n environmentRadiance = texture2D(reflection2DSampler, coords, bias).rgb * vReflectionInfos.x;\n #endif\n environmentRadiance = toLinearSpace(environmentRadiance.rgb);\n environmentIrradiance = texture2D(reflection2DSampler, coords, 20.).rgb * vReflectionInfos.x;\n environmentIrradiance = toLinearSpace(environmentIrradiance.rgb);\n #endif\n#endif\n#ifdef OVERLOADEDVALUES\n environmentIrradiance = mix(environmentIrradiance, vOverloadedReflection, vOverloadedMicroSurface.z);\n environmentRadiance = mix(environmentRadiance, vOverloadedReflection, vOverloadedMicroSurface.z);\n#endif\nenvironmentRadiance *= vLightingIntensity.z;\nenvironmentIrradiance *= vLightingIntensity.z;\n\nvec3 specularEnvironmentR0 = surfaceReflectivityColor.rgb;\nvec3 specularEnvironmentR90 = vec3(1.0, 1.0, 1.0);\nvec3 specularEnvironmentReflectance = FresnelSchlickEnvironmentGGX(clamp(NdotV, 0., 1.), specularEnvironmentR0, specularEnvironmentR90, sqrt(microSurface));\n\nvec3 refractance = vec3(0.0 , 0.0, 0.0);\n#ifdef REFRACTION\n vec3 transmission = vec3(1.0 , 1.0, 1.0);\n #ifdef LINKREFRACTIONTOTRANSPARENCY\n \n transmission *= (1.0 - alpha);\n \n \n vec3 mixedAlbedo = surfaceAlbedoContribution.rgb * surfaceAlbedo.rgb;\n float maxChannel = max(max(mixedAlbedo.r, mixedAlbedo.g), mixedAlbedo.b);\n vec3 tint = clamp(maxChannel * mixedAlbedo, 0.0, 1.0);\n \n surfaceAlbedoContribution *= alpha;\n \n environmentIrradiance *= alpha;\n \n surfaceRefractionColor *= tint;\n \n alpha = 1.0;\n #endif\n \n vec3 bounceSpecularEnvironmentReflectance = (2.0 * specularEnvironmentReflectance) / (1.0 + specularEnvironmentReflectance);\n specularEnvironmentReflectance = mix(bounceSpecularEnvironmentReflectance, specularEnvironmentReflectance, alpha);\n \n transmission *= 1.0 - specularEnvironmentReflectance;\n \n refractance = surfaceRefractionColor * transmission;\n#endif\n\nfloat reflectance = max(max(surfaceReflectivityColor.r, surfaceReflectivityColor.g), surfaceReflectivityColor.b);\nsurfaceAlbedo.rgb = (1. - reflectance) * surfaceAlbedo.rgb;\nrefractance *= vLightingIntensity.z;\nenvironmentRadiance *= specularEnvironmentReflectance;\n\nvec3 surfaceEmissiveColor = vEmissiveColor;\n#ifdef EMISSIVE\n vec3 emissiveColorTex = texture2D(emissiveSampler, vEmissiveUV).rgb;\n surfaceEmissiveColor = toLinearSpace(emissiveColorTex.rgb) * surfaceEmissiveColor * vEmissiveInfos.y;\n#endif\n#ifdef OVERLOADEDVALUES\n surfaceEmissiveColor = mix(surfaceEmissiveColor, vOverloadedEmissive, vOverloadedIntensity.w);\n#endif\n#ifdef EMISSIVEFRESNEL\n float emissiveFresnelTerm = computeFresnelTerm(viewDirectionW, normalW, emissiveRightColor.a, emissiveLeftColor.a);\n surfaceEmissiveColor *= emissiveLeftColor.rgb * (1.0 - emissiveFresnelTerm) + emissiveFresnelTerm * emissiveRightColor.rgb;\n#endif\n\n#ifdef EMISSIVEASILLUMINATION\n vec3 finalDiffuse = max(lightDiffuseContribution * surfaceAlbedoContribution + vAmbientColor, 0.0) * surfaceAlbedo.rgb;\n #ifdef OVERLOADEDSHADOWVALUES\n shadowedOnlyLightDiffuseContribution = max(shadowedOnlyLightDiffuseContribution * surfaceAlbedoContribution + vAmbientColor, 0.0) * surfaceAlbedo.rgb;\n #endif\n#else\n #ifdef LINKEMISSIVEWITHALBEDO\n vec3 finalDiffuse = max((lightDiffuseContribution + surfaceEmissiveColor) * surfaceAlbedoContribution + vAmbientColor, 0.0) * surfaceAlbedo.rgb;\n #ifdef OVERLOADEDSHADOWVALUES\n shadowedOnlyLightDiffuseContribution = max((shadowedOnlyLightDiffuseContribution + surfaceEmissiveColor) * surfaceAlbedoContribution + vAmbientColor, 0.0) * surfaceAlbedo.rgb;\n #endif\n #else\n vec3 finalDiffuse = max(lightDiffuseContribution * surfaceAlbedoContribution + surfaceEmissiveColor + vAmbientColor, 0.0) * surfaceAlbedo.rgb;\n #ifdef OVERLOADEDSHADOWVALUES\n shadowedOnlyLightDiffuseContribution = max(shadowedOnlyLightDiffuseContribution * surfaceAlbedoContribution + surfaceEmissiveColor + vAmbientColor, 0.0) * surfaceAlbedo.rgb;\n #endif\n #endif\n#endif\n#ifdef OVERLOADEDSHADOWVALUES\n finalDiffuse = mix(finalDiffuse, shadowedOnlyLightDiffuseContribution, (1.0 - vOverloadedShadowIntensity.y));\n#endif\n#ifdef SPECULARTERM\n vec3 finalSpecular = lightSpecularContribution * surfaceReflectivityColor;\n#else\n vec3 finalSpecular = vec3(0.0);\n#endif\n#ifdef SPECULAROVERALPHA\n alpha = clamp(alpha + getLuminance(finalSpecular), 0., 1.);\n#endif\n#ifdef RADIANCEOVERALPHA\n alpha = clamp(alpha + getLuminance(environmentRadiance), 0., 1.);\n#endif\n\n\n#ifdef EMISSIVEASILLUMINATION\n vec4 finalColor = vec4(finalDiffuse * ambientColor * vLightingIntensity.x + surfaceAlbedo.rgb * environmentIrradiance + finalSpecular * vLightingIntensity.x + environmentRadiance + surfaceEmissiveColor * vLightingIntensity.y + refractance, alpha);\n#else\n vec4 finalColor = vec4(finalDiffuse * ambientColor * vLightingIntensity.x + surfaceAlbedo.rgb * environmentIrradiance + finalSpecular * vLightingIntensity.x + environmentRadiance + refractance, alpha);\n#endif\n#ifdef LIGHTMAP\n vec3 lightmapColor = texture2D(lightmapSampler, vLightmapUV).rgb * vLightmapInfos.y;\n #ifdef USELIGHTMAPASSHADOWMAP\n finalColor.rgb *= lightmapColor;\n #else\n finalColor.rgb += lightmapColor;\n #endif\n#endif\n finalColor = max(finalColor, 0.0);\n#ifdef CAMERATONEMAP\n finalColor.rgb = toneMaps(finalColor.rgb);\n#endif\n finalColor.rgb = toGammaSpace(finalColor.rgb);\n#ifdef CAMERACONTRAST\n finalColor = contrasts(finalColor);\n#endif\n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n#include<logDepthFragment>\n#include<fogFragment>(color, finalColor)\n gl_FragColor = finalColor;\n}",
BABYLON.Effect.ShadersStore.legacypbrVertexShader="precision mediump float;\n\nattribute vec3 position;\nattribute vec3 normal;\n#ifdef UV1\nattribute vec2 uv;\n#endif\n#ifdef UV2\nattribute vec2 uv2;\n#endif\n#ifdef VERTEXCOLOR\nattribute vec4 color;\n#endif\n#include<bonesDeclaration>\n\nuniform mat4 world;\nuniform mat4 view;\nuniform mat4 viewProjection;\n#ifdef ALBEDO\nvarying vec2 vAlbedoUV;\nuniform mat4 albedoMatrix;\nuniform vec2 vAlbedoInfos;\n#endif\n#ifdef AMBIENT\nvarying vec2 vAmbientUV;\nuniform mat4 ambientMatrix;\nuniform vec2 vAmbientInfos;\n#endif\n#ifdef OPACITY\nvarying vec2 vOpacityUV;\nuniform mat4 opacityMatrix;\nuniform vec2 vOpacityInfos;\n#endif\n#ifdef EMISSIVE\nvarying vec2 vEmissiveUV;\nuniform vec2 vEmissiveInfos;\nuniform mat4 emissiveMatrix;\n#endif\n#if defined(REFLECTIVITY)\nvarying vec2 vReflectivityUV;\nuniform vec2 vReflectivityInfos;\nuniform mat4 reflectivityMatrix;\n#endif\n\nvarying vec3 vPositionW;\nvarying vec3 vNormalW;\n#ifdef VERTEXCOLOR\nvarying vec4 vColor;\n#endif\n#include<clipPlaneVertexDeclaration>\nvoid main(void) {\n mat4 finalWorld = world;\n#include<bonesVertex>\n finalWorld = finalWorld * influence;\n#endif\n gl_Position = viewProjection * finalWorld * vec4(position, 1.0);\n vec4 worldPos = finalWorld * vec4(position, 1.0);\n vPositionW = vec3(worldPos);\n vNormalW = normalize(vec3(finalWorld * vec4(normal, 0.0)));\n \n#ifndef UV1\n vec2 uv = vec2(0., 0.);\n#endif\n#ifndef UV2\n vec2 uv2 = vec2(0., 0.);\n#endif\n#ifdef ALBEDO\n if (vAlbedoInfos.x == 0.)\n {\n vAlbedoUV = vec2(albedoMatrix * vec4(uv, 1.0, 0.0));\n }\n else\n {\n vAlbedoUV = vec2(albedoMatrix * vec4(uv2, 1.0, 0.0));\n }\n#endif\n#ifdef AMBIENT\n if (vAmbientInfos.x == 0.)\n {\n vAmbientUV = vec2(ambientMatrix * vec4(uv, 1.0, 0.0));\n }\n else\n {\n vAmbientUV = vec2(ambientMatrix * vec4(uv2, 1.0, 0.0));\n }\n#endif\n#ifdef OPACITY\n if (vOpacityInfos.x == 0.)\n {\n vOpacityUV = vec2(opacityMatrix * vec4(uv, 1.0, 0.0));\n }\n else\n {\n vOpacityUV = vec2(opacityMatrix * vec4(uv2, 1.0, 0.0));\n }\n#endif\n#ifdef EMISSIVE\n if (vEmissiveInfos.x == 0.)\n {\n vEmissiveUV = vec2(emissiveMatrix * vec4(uv, 1.0, 0.0));\n }\n else\n {\n vEmissiveUV = vec2(emissiveMatrix * vec4(uv2, 1.0, 0.0));\n }\n#endif\n#if defined(REFLECTIVITY)\n if (vReflectivityInfos.x == 0.)\n {\n vReflectivityUV = vec2(reflectivityMatrix * vec4(uv, 1.0, 0.0));\n }\n else\n {\n vReflectivityUV = vec2(reflectivityMatrix * vec4(uv2, 1.0, 0.0));\n }\n#endif\n#include<clipPlaneVertex>\n \n#ifdef VERTEXCOLOR\n vColor = color;\n#endif\n}",BABYLON.Effect.ShadersStore.legacypbrPixelShader="precision mediump float;\n\n#define RECIPROCAL_PI2 0.15915494\n#define FRESNEL_MAXIMUM_ON_ROUGH 0.25\nuniform vec3 vEyePosition;\nuniform vec3 vAmbientColor;\nuniform vec4 vAlbedoColor;\nuniform vec3 vReflectionColor;\n\nuniform vec4 vLightingIntensity;\nuniform vec4 vCameraInfos;\n#ifdef OVERLOADEDVALUES\nuniform vec4 vOverloadedIntensity;\nuniform vec3 vOverloadedAmbient;\nuniform vec3 vOverloadedAlbedo;\nuniform vec3 vOverloadedReflectivity;\nuniform vec3 vOverloadedEmissive;\nuniform vec3 vOverloadedReflection;\nuniform vec3 vOverloadedMicroSurface;\n#endif\n#ifdef OVERLOADEDSHADOWVALUES\nuniform vec4 vOverloadedShadowIntensity;\n#endif\n\nconst float kPi = 3.1415926535897932384626433832795;\n\nfloat Square(float value)\n{\n return value * value;\n}\nfloat getLuminance(vec3 color)\n{\n return clamp(dot(color, vec3(0.2126, 0.7152, 0.0722)), 0., 1.);\n}\nfloat convertRoughnessToAverageSlope(float roughness)\n{\n \n const float kMinimumVariance = 0.0005;\n float alphaG = Square(roughness) + kMinimumVariance;\n return alphaG;\n}\n\nfloat smithVisibilityG1_TrowbridgeReitzGGX(float dot, float alphaG)\n{\n float tanSquared = (1.0 - dot * dot) / (dot * dot);\n return 2.0 / (1.0 + sqrt(1.0 + alphaG * alphaG * tanSquared));\n}\nfloat smithVisibilityG_TrowbridgeReitzGGX_Walter(float NdotL, float NdotV, float alphaG)\n{\n return smithVisibilityG1_TrowbridgeReitzGGX(NdotL, alphaG) * smithVisibilityG1_TrowbridgeReitzGGX(NdotV, alphaG);\n}\n\n\nfloat normalDistributionFunction_TrowbridgeReitzGGX(float NdotH, float alphaG)\n{\n \n \n \n float a2 = Square(alphaG);\n float d = NdotH * NdotH * (a2 - 1.0) + 1.0;\n return a2 / (kPi * d * d);\n}\nvec3 fresnelSchlickGGX(float VdotH, vec3 reflectance0, vec3 reflectance90)\n{\n return reflectance0 + (reflectance90 - reflectance0) * pow(clamp(1.0 - VdotH, 0., 1.), 5.0);\n}\nvec3 FresnelSchlickEnvironmentGGX(float VdotN, vec3 reflectance0, vec3 reflectance90, float smoothness)\n{\n \n float weight = mix(FRESNEL_MAXIMUM_ON_ROUGH, 1.0, smoothness);\n return reflectance0 + weight * (reflectance90 - reflectance0) * pow(clamp(1.0 - VdotN, 0., 1.), 5.0);\n}\n\nvec3 computeSpecularTerm(float NdotH, float NdotL, float NdotV, float VdotH, float roughness, vec3 specularColor)\n{\n float alphaG = convertRoughnessToAverageSlope(roughness);\n float distribution = normalDistributionFunction_TrowbridgeReitzGGX(NdotH, alphaG);\n float visibility = smithVisibilityG_TrowbridgeReitzGGX_Walter(NdotL, NdotV, alphaG);\n visibility /= (4.0 * NdotL * NdotV); \n vec3 fresnel = fresnelSchlickGGX(VdotH, specularColor, vec3(1., 1., 1.));\n float specTerm = max(0., visibility * distribution) * NdotL;\n return fresnel * specTerm;\n}\nfloat computeDiffuseTerm(float NdotL, float NdotV, float VdotH, float roughness)\n{\n \n \n float diffuseFresnelNV = pow(clamp(1.0 - NdotL, 0.000001, 1.), 5.0);\n float diffuseFresnelNL = pow(clamp(1.0 - NdotV, 0.000001, 1.), 5.0);\n float diffuseFresnel90 = 0.5 + 2.0 * VdotH * VdotH * roughness;\n float diffuseFresnelTerm =\n (1.0 + (diffuseFresnel90 - 1.0) * diffuseFresnelNL) *\n (1.0 + (diffuseFresnel90 - 1.0) * diffuseFresnelNV);\n return diffuseFresnelTerm * NdotL;\n}\nfloat computeDefaultMicroSurface(float microSurface, vec3 reflectivityColor)\n{\n if (microSurface == 0.)\n {\n float kReflectivityNoAlphaWorkflow_SmoothnessMax = 0.95;\n float reflectivityLuminance = getLuminance(reflectivityColor);\n float reflectivityLuma = sqrt(reflectivityLuminance);\n microSurface = reflectivityLuma * kReflectivityNoAlphaWorkflow_SmoothnessMax;\n }\n return microSurface;\n}\nvec3 toLinearSpace(vec3 color)\n{\n return vec3(pow(color.r, 2.2), pow(color.g, 2.2), pow(color.b, 2.2));\n}\nvec3 toGammaSpace(vec3 color)\n{\n return vec3(pow(color.r, 1.0 / 2.2), pow(color.g, 1.0 / 2.2), pow(color.b, 1.0 / 2.2));\n}\n#ifdef CAMERATONEMAP\n vec3 toneMaps(vec3 color)\n {\n color = max(color, 0.0);\n \n color.rgb = color.rgb * vCameraInfos.x;\n float tuning = 1.5; \n vec3 tonemapped = 1.0 - exp2(-color.rgb * tuning); \n color.rgb = mix(color.rgb, tonemapped, 1.0);\n return color;\n }\n#endif\n#ifdef CAMERACONTRAST\n vec4 contrasts(vec4 color)\n {\n color = clamp(color, 0.0, 1.0);\n vec3 resultHighContrast = color.rgb * color.rgb * (3.0 - 2.0 * color.rgb);\n float contrast = vCameraInfos.y;\n if (contrast < 1.0)\n {\n \n color.rgb = mix(vec3(0.5, 0.5, 0.5), color.rgb, contrast);\n }\n else\n {\n \n color.rgb = mix(color.rgb, resultHighContrast, contrast - 1.0);\n }\n return color;\n }\n#endif\n\nuniform vec4 vReflectivityColor;\nuniform vec3 vEmissiveColor;\n\nvarying vec3 vPositionW;\n#ifdef NORMAL\nvarying vec3 vNormalW;\n#endif\n#ifdef VERTEXCOLOR\nvarying vec4 vColor;\n#endif\n\n#include<light0FragmentDeclaration>\n#include<light1FragmentDeclaration>\n#include<light2FragmentDeclaration>\n#include<light3FragmentDeclaration>\n\n#ifdef ALBEDO\nvarying vec2 vAlbedoUV;\nuniform sampler2D albedoSampler;\nuniform vec2 vAlbedoInfos;\n#endif\n#ifdef AMBIENT\nvarying vec2 vAmbientUV;\nuniform sampler2D ambientSampler;\nuniform vec2 vAmbientInfos;\n#endif\n#ifdef OPACITY \nvarying vec2 vOpacityUV;\nuniform sampler2D opacitySampler;\nuniform vec2 vOpacityInfos;\n#endif\n#ifdef EMISSIVE\nvarying vec2 vEmissiveUV;\nuniform vec2 vEmissiveInfos;\nuniform sampler2D emissiveSampler;\n#endif\n#ifdef LIGHTMAP\nvarying vec2 vLightmapUV;\nuniform vec2 vLightmapInfos;\nuniform sampler2D lightmapSampler;\n#endif\n#if defined(REFLECTIVITY)\nvarying vec2 vReflectivityUV;\nuniform vec2 vReflectivityInfos;\nuniform sampler2D reflectivitySampler;\n#endif\n#include<clipPlaneFragmentDeclaration>\n\nstruct lightingInfo\n{\n vec3 diffuse;\n#ifdef SPECULARTERM\n vec3 specular;\n#endif\n};\nlightingInfo computeLighting(vec3 viewDirectionW, vec3 vNormal, vec4 lightData, vec3 diffuseColor, vec3 specularColor, float range, float roughness, float NdotV) {\n lightingInfo result;\n vec3 lightVectorW;\n float attenuation = 1.0;\n if (lightData.w == 0.)\n {\n vec3 direction = lightData.xyz - vPositionW;\n attenuation = max(0., 1.0 - length(direction) / range);\n lightVectorW = normalize(direction);\n }\n else\n {\n lightVectorW = normalize(-lightData.xyz);\n }\n \n vec3 H = normalize(viewDirectionW + lightVectorW);\n float NdotL = max(0.00000000001, dot(vNormal, lightVectorW));\n float VdotH = clamp(0.00000000001, 1.0, dot(viewDirectionW, H));\n float diffuseTerm = computeDiffuseTerm(NdotL, NdotV, VdotH, roughness);\n result.diffuse = diffuseTerm * diffuseColor * attenuation;\n#ifdef SPECULARTERM\n \n float NdotH = max(0.00000000001, dot(vNormal, H));\n vec3 specTerm = computeSpecularTerm(NdotH, NdotL, NdotV, VdotH, roughness, specularColor);\n result.specular = specTerm * specularColor * attenuation;\n#endif\n return result;\n}\nlightingInfo computeSpotLighting(vec3 viewDirectionW, vec3 vNormal, vec4 lightData, vec4 lightDirection, vec3 diffuseColor, vec3 specularColor, float range, float roughness, float NdotV) {\n lightingInfo result;\n vec3 direction = lightData.xyz - vPositionW;\n vec3 lightVectorW = normalize(direction);\n float attenuation = max(0., 1.0 - length(direction) / range);\n \n float cosAngle = max(0.0000001, dot(-lightDirection.xyz, lightVectorW));\n float spotAtten = 0.0;\n if (cosAngle >= lightDirection.w)\n {\n cosAngle = max(0., pow(cosAngle, lightData.w));\n spotAtten = clamp((cosAngle - lightDirection.w) / (1. - cosAngle), 0.0, 1.0);\n \n vec3 H = normalize(viewDirectionW - lightDirection.xyz);\n float NdotL = max(0.00000000001, dot(vNormal, -lightDirection.xyz));\n float VdotH = clamp(dot(viewDirectionW, H), 0.00000000001, 1.0);\n float diffuseTerm = computeDiffuseTerm(NdotL, NdotV, VdotH, roughness);\n result.diffuse = diffuseTerm * diffuseColor * attenuation * spotAtten;\n#ifdef SPECULARTERM\n \n float NdotH = max(0.00000000001, dot(vNormal, H));\n vec3 specTerm = computeSpecularTerm(NdotH, NdotL, NdotV, VdotH, roughness, specularColor);\n result.specular = specTerm * specularColor * attenuation * spotAtten;\n#endif\n return result;\n }\n result.diffuse = vec3(0.);\n#ifdef SPECULARTERM\n result.specular = vec3(0.);\n#endif\n return result;\n}\nlightingInfo computeHemisphericLighting(vec3 viewDirectionW, vec3 vNormal, vec4 lightData, vec3 diffuseColor, vec3 specularColor, vec3 groundColor, float roughness, float NdotV) {\n lightingInfo result;\n vec3 lightVectorW = normalize(lightData.xyz);\n \n float ndl = dot(vNormal, lightData.xyz) * 0.5 + 0.5;\n result.diffuse = mix(groundColor, diffuseColor, ndl);\n#ifdef SPECULARTERM\n \n vec3 H = normalize(viewDirectionW + lightVectorW);\n float NdotH = max(0.00000000001, dot(vNormal, H));\n float NdotL = max(0.00000000001, ndl);\n float VdotH = clamp(0.00000000001, 1.0, dot(viewDirectionW, H));\n vec3 specTerm = computeSpecularTerm(NdotH, NdotL, NdotV, VdotH, roughness, specularColor);\n result.specular = specTerm * specularColor;\n#endif\n return result;\n}\nvoid main(void) {\n#include<clipPlaneFragment>\n vec3 viewDirectionW = normalize(vEyePosition - vPositionW);\n \n vec4 baseColor = vec4(1., 1., 1., 1.);\n vec3 diffuseColor = vAlbedoColor.rgb;\n \n float alpha = vAlbedoColor.a;\n#ifdef ALBEDO\n baseColor = texture2D(diffuseSampler, vAlbedoUV);\n baseColor = vec4(toLinearSpace(baseColor.rgb), baseColor.a);\n#ifdef ALPHATEST\n if (baseColor.a < 0.4)\n discard;\n#endif\n#ifdef ALPHAFROMALBEDO\n alpha *= baseColor.a;\n#endif\n baseColor.rgb *= vAlbedoInfos.y;\n#endif\n#ifdef VERTEXCOLOR\n baseColor.rgb *= vColor.rgb;\n#endif\n#ifdef OVERLOADEDVALUES\n baseColor.rgb = mix(baseColor.rgb, vOverloadedAlbedo, vOverloadedIntensity.y);\n albedoColor.rgb = mix(albedoColor.rgb, vOverloadedAlbedo, vOverloadedIntensity.y);\n#endif\n \n#ifdef NORMAL\n vec3 normalW = normalize(vNormalW);\n#else\n vec3 normalW = vec3(1.0, 1.0, 1.0);\n#endif\n \n vec3 baseAmbientColor = vec3(1., 1., 1.);\n#ifdef AMBIENT\n baseAmbientColor = texture2D(ambientSampler, vAmbientUV).rgb * vAmbientInfos.y;\n #ifdef OVERLOADEDVALUES\n baseAmbientColor.rgb = mix(baseAmbientColor.rgb, vOverloadedAmbient, vOverloadedIntensity.x);\n #endif\n#endif\n \n float microSurface = vReflectivityColor.a;\n vec3 reflectivityColor = vReflectivityColor.rgb;\n #ifdef OVERLOADEDVALUES\n reflectivityColor.rgb = mix(reflectivityColor.rgb, vOverloadedReflectivity, vOverloadedIntensity.z);\n #endif\n #ifdef REFLECTIVITY\n vec4 reflectivityMapColor = texture2D(reflectivitySampler, vReflectivityUV);\n reflectivityColor = toLinearSpace(reflectivityMapColor.rgb);\n #ifdef OVERLOADEDVALUES\n reflectivityColor.rgb = mix(reflectivityColor.rgb, vOverloadedReflectivity, vOverloadedIntensity.z);\n #endif\n #ifdef MICROSURFACEFROMREFLECTIVITYMAP\n microSurface = reflectivityMapColor.a;\n #else\n microSurface = computeDefaultMicroSurface(microSurface, reflectivityColor);\n #endif\n #endif\n #ifdef OVERLOADEDVALUES\n microSurface = mix(microSurface, vOverloadedMicroSurface.x, vOverloadedMicroSurface.y);\n #endif\n \n float reflectance = max(max(reflectivityColor.r, reflectivityColor.g), reflectivityColor.b);\n baseColor.rgb = (1. - reflectance) * baseColor.rgb;\n \n float NdotV = max(0.00000000001, dot(normalW, viewDirectionW));\n \n microSurface = clamp(microSurface, 0., 1.) * 0.98;\n \n float rough = clamp(1. - microSurface, 0.000001, 1.0);\n \n vec3 diffuseBase = vec3(0., 0., 0.);\n#ifdef OVERLOADEDSHADOWVALUES\n vec3 shadowedOnlyDiffuseBase = vec3(1., 1., 1.);\n#endif\n#ifdef SPECULARTERM\n vec3 specularBase = vec3(0., 0., 0.);\n#endif\n float shadow = 1.;\n#ifdef LIGHT0\n#ifndef SPECULARTERM\n vec3 vLightSpecular0 = vec3(0.0);\n#endif\n#ifdef SPOTLIGHT0\n lightingInfo info = computeSpotLighting(viewDirectionW, normalW, vLightData0, vLightDirection0, vLightDiffuse0.rgb, vLightSpecular0, vLightDiffuse0.a, rough, NdotV);\n#endif\n#ifdef HEMILIGHT0\n lightingInfo info = computeHemisphericLighting(viewDirectionW, normalW, vLightData0, vLightDiffuse0.rgb, vLightSpecular0, vLightGround0, rough, NdotV);\n#endif\n#if defined(POINTLIGHT0) || defined(DIRLIGHT0)\n lightingInfo info = computeLighting(viewDirectionW, normalW, vLightData0, vLightDiffuse0.rgb, vLightSpecular0, vLightDiffuse0.a, rough, NdotV);\n#endif\n shadow = 1.;\n diffuseBase += info.diffuse * shadow;\n#ifdef OVERLOADEDSHADOWVALUES\n shadowedOnlyDiffuseBase *= shadow;\n#endif\n#ifdef SPECULARTERM\n specularBase += info.specular * shadow;\n#endif\n#endif\n#ifdef LIGHT1\n#ifndef SPECULARTERM\n vec3 vLightSpecular1 = vec3(0.0);\n#endif\n#ifdef SPOTLIGHT1\n info = computeSpotLighting(viewDirectionW, normalW, vLightData1, vLightDirection1, vLightDiffuse1.rgb, vLightSpecular1, vLightDiffuse1.a, rough, NdotV);\n#endif\n#ifdef HEMILIGHT1\n info = computeHemisphericLighting(viewDirectionW, normalW, vLightData1, vLightDiffuse1.rgb, vLightSpecular1, vLightGround1, rough, NdotV);\n#endif\n#if defined(POINTLIGHT1) || defined(DIRLIGHT1)\n info = computeLighting(viewDirectionW, normalW, vLightData1, vLightDiffuse1.rgb, vLightSpecular1, vLightDiffuse1.a, rough, NdotV);\n#endif\n shadow = 1.;\n diffuseBase += info.diffuse * shadow;\n#ifdef OVERLOADEDSHADOWVALUES\n shadowedOnlyDiffuseBase *= shadow;\n#endif\n#ifdef SPECULARTERM\n specularBase += info.specular * shadow;\n#endif\n#endif\n#ifdef LIGHT2\n#ifndef SPECULARTERM\n vec3 vLightSpecular2 = vec3(0.0);\n#endif\n#ifdef SPOTLIGHT2\n info = computeSpotLighting(viewDirectionW, normalW, vLightData2, vLightDirection2, vLightDiffuse2.rgb, vLightSpecular2, vLightDiffuse2.a, rough, NdotV);\n#endif\n#ifdef HEMILIGHT2\n info = computeHemisphericLighting(viewDirectionW, normalW, vLightData2, vLightDiffuse2.rgb, vLightSpecular2, vLightGround2, rough, NdotV);\n#endif\n#if defined(POINTLIGHT2) || defined(DIRLIGHT2)\n info = computeLighting(viewDirectionW, normalW, vLightData2, vLightDiffuse2.rgb, vLightSpecular2, vLightDiffuse2.a, rough, NdotV);\n#endif\n shadow = 1.;\n diffuseBase += info.diffuse * shadow;\n#ifdef OVERLOADEDSHADOWVALUES\n shadowedOnlyDiffuseBase *= shadow;\n#endif\n#ifdef SPECULARTERM\n specularBase += info.specular * shadow;\n#endif\n#endif\n#ifdef LIGHT3\n#ifndef SPECULARTERM\n vec3 vLightSpecular3 = vec3(0.0);\n#endif\n#ifdef SPOTLIGHT3\n info = computeSpotLighting(viewDirectionW, normalW, vLightData3, vLightDirection3, vLightDiffuse3.rgb, vLightSpecular3, vLightDiffuse3.a, rough, NdotV);\n#endif\n#ifdef HEMILIGHT3\n info = computeHemisphericLighting(viewDirectionW, normalW, vLightData3, vLightDiffuse3.rgb, vLightSpecular3, vLightGround3, rough, NdotV);\n#endif\n#if defined(POINTLIGHT3) || defined(DIRLIGHT3)\n info = computeLighting(viewDirectionW, normalW, vLightData3, vLightDiffuse3.rgb, vLightSpecular3, vLightDiffuse3.a, rough, NdotV);\n#endif\n shadow = 1.;\n diffuseBase += info.diffuse * shadow;\n#ifdef OVERLOADEDSHADOWVALUES\n shadowedOnlyDiffuseBase *= shadow;\n#endif\n#ifdef SPECULARTERM\n specularBase += info.specular * shadow;\n#endif\n#endif\n\nvec3 reflectionColor = vReflectionColor.rgb;\nvec3 ambientReflectionColor = vReflectionColor.rgb;\nreflectionColor *= vLightingIntensity.z;\nambientReflectionColor *= vLightingIntensity.z;\n\nvec3 reflectivityEnvironmentR0 = reflectivityColor.rgb;\nvec3 reflectivityEnvironmentR90 = vec3(1.0, 1.0, 1.0);\nvec3 reflectivityEnvironmentReflectanceViewer = FresnelSchlickEnvironmentGGX(clamp(NdotV, 0., 1.), reflectivityEnvironmentR0, reflectivityEnvironmentR90, sqrt(microSurface));\nreflectionColor *= reflectivityEnvironmentReflectanceViewer;\n#ifdef OVERLOADEDVALUES\n ambientReflectionColor = mix(ambientReflectionColor, vOverloadedReflection, vOverloadedMicroSurface.z);\n reflectionColor = mix(reflectionColor, vOverloadedReflection, vOverloadedMicroSurface.z);\n#endif\n#ifdef OPACITY\n vec4 opacityMap = texture2D(opacitySampler, vOpacityUV);\n#ifdef OPACITYRGB\n opacityMap.rgb = opacityMap.rgb * vec3(0.3, 0.59, 0.11);\n alpha *= (opacityMap.x + opacityMap.y + opacityMap.z)* vOpacityInfos.y;\n#else\n alpha *= opacityMap.a * vOpacityInfos.y;\n#endif\n#endif\n#ifdef VERTEXALPHA\n alpha *= vColor.a;\n#endif\n \n vec3 emissiveColor = vEmissiveColor;\n#ifdef EMISSIVE\n vec3 emissiveColorTex = texture2D(emissiveSampler, vEmissiveUV).rgb;\n emissiveColor = toLinearSpace(emissiveColorTex.rgb) * emissiveColor * vEmissiveInfos.y;\n#endif\n#ifdef OVERLOADEDVALUES\n emissiveColor = mix(emissiveColor, vOverloadedEmissive, vOverloadedIntensity.w);\n#endif\n \n#ifdef EMISSIVEASILLUMINATION\n vec3 finalDiffuse = max(diffuseBase * albedoColor + vAmbientColor, 0.0) * baseColor.rgb;\n #ifdef OVERLOADEDSHADOWVALUES\n shadowedOnlyDiffuseBase = max(shadowedOnlyDiffuseBase * albedoColor + vAmbientColor, 0.0) * baseColor.rgb;\n #endif\n#else\n #ifdef LINKEMISSIVEWITHALBEDO\n vec3 finalDiffuse = max((diffuseBase + emissiveColor) * albedoColor + vAmbientColor, 0.0) * baseColor.rgb;\n #ifdef OVERLOADEDSHADOWVALUES\n shadowedOnlyDiffuseBase = max((shadowedOnlyDiffuseBase + emissiveColor) * albedoColor + vAmbientColor, 0.0) * baseColor.rgb;\n #endif\n #else\n vec3 finalDiffuse = max(diffuseBase * albedoColor + emissiveColor + vAmbientColor, 0.0) * baseColor.rgb;\n #ifdef OVERLOADEDSHADOWVALUES\n shadowedOnlyDiffuseBase = max(shadowedOnlyDiffuseBase * albedoColor + emissiveColor + vAmbientColor, 0.0) * baseColor.rgb;\n #endif\n #endif\n#endif\n#ifdef OVERLOADEDSHADOWVALUES\n finalDiffuse = mix(finalDiffuse, shadowedOnlyDiffuseBase, (1.0 - vOverloadedShadowIntensity.y));\n#endif\n\n\nfinalDiffuse += baseColor.rgb * ambientReflectionColor * 0.2;\n#ifdef SPECULARTERM\n vec3 finalSpecular = specularBase * reflectivityColor * vLightingIntensity.w;\n#else\n vec3 finalSpecular = vec3(0.0);\n#endif\n#ifdef SPECULAROVERALPHA\n alpha = clamp(alpha + dot(finalSpecular, vec3(0.3, 0.59, 0.11)), 0., 1.);\n#endif\n\n\n#ifdef EMISSIVEASILLUMINATION\n vec4 color = vec4(finalDiffuse * baseAmbientColor * vLightingIntensity.x + finalSpecular * vLightingIntensity.x + reflectionColor + emissiveColor * vLightingIntensity.y, alpha);\n#else\n vec4 color = vec4(finalDiffuse * baseAmbientColor * vLightingIntensity.x + finalSpecular * vLightingIntensity.x + reflectionColor, alpha);\n#endif\n color = max(color, 0.0);\n#ifdef CAMERATONEMAP\n color.rgb = toneMaps(color.rgb);\n#endif\n color.rgb = toGammaSpace(color.rgb);\n#ifdef CAMERACONTRAST\n color = contrasts(color);\n#endif\n gl_FragColor = color;\n}";